{"pages":[],"posts":[{"title":"sql语句中参数的传递","text":"&emsp;&emsp;通过Mybatis的使用，开发人员只需要专心提供SQL语句即可，这篇文章介绍了SQL语句中参数传递的问题。大致有以下几种方式： 1. 单个参数传递123//在接口中定义放法，参数形式如下//使用单个参数Student selectById(int id); 123456789&lt;!-- 使用单个参数查询： parameterType：表示参数数据类型（可不写） 使用 #{参数名} 获取参数的值 对参数名称无要求--&gt;&lt;select id=\"selectById\" parameterType=\"int\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where id = #{id}&lt;/select&gt; 12//调用方法时只需要传入相应类型的单个值即可Student student = dao.selectById(2); 2. 使用@param为参数命名传递多个参数12345/* 在接口文件的对应方法形参中，使用以下格式进行命名* 多个参数：为参数命名，在形参前加上 @Param(\"自定义参数名\")* */List&lt;Student&gt; selectMultiParam(@Param(\"myname\") String name, @Param(\"myage\") Integer age); 12//调用时传入对应的参数值List&lt;Student&gt; students = dao.selectMultiParam(\"康康\",23); 123456&lt;!-- 多个参数：使用param命名 使用为参数起得名称 eg：#{命名}--&gt;&lt;select id=\"selectMultiParam\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{myname} or age=#{myage}&lt;/select&gt; 3. 使用Java对象作为方法的参数123//在接口中定义放法，参数形式如下//多个参数：使用java对象作为方法的参数List&lt;Student&gt; selectMultiObject(QueryParam queryParam); 12345678910&lt;!-- 多个参数：使用java对象的属性值作为参数实际值 原始语法：#{属性名, javaType=java中类型名称, jdbcType=数据库中的类型名} eg: #{queryName, javaType=String, jdbcType=Varchar} #{queryAge, javaType=Integer, jdbcType=Integer} 简写：#{属性名}--&gt;&lt;select id=\"selectMultiObject\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{queryName} or age=#{queryAge}&lt;/select&gt; 12//调用时传入相应对象List&lt;Student&gt; students = dao.selectMultiObject(queryParam); 4. 使用位置传参&emsp;&emsp;在方法的参数中，形参的顺序对应映射文件中参数的顺序，arg0指形参中第一个值，arg1代表第二个，以此类推。 123//在接口中定义放法，参数形式如下//多个参数：使用位置传参List&lt;Student&gt; selectMultiPosition(String name, Integer age); 1234&lt;!--根据参数位置传参 arg后面的数字代表参数所在的位置--&gt;&lt;select id=\"selectMultiPosition\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{arg0} or age=#{arg1}&lt;/select&gt; 12//调用代码List&lt;Student&gt; students = dao.selectMultiPosition(\"康康\", 23); 5. 使用map传参123//在接口中定义放法，参数形式如下//使用Map传递多个参数List&lt;Student&gt; selectMultiMap(Map&lt;String, Object&gt; map); 1234&lt;!--使用Map键值对传参，形式：#{key名}--&gt;&lt;select id=\"selectMultiMap\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{mapName} or age=#{mapAge}&lt;/select&gt; 12345//调用Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();data.put(\"mapName\",\"krain\");data.put(\"mapAge\",23);List&lt;Student&gt; students = dao.selectMultiMap(data);","link":"/2020/07/17/sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/16/hello-world/"},{"title":"SpringBoot中使用拦截器","text":"一、创建Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.krain.springboot.web;import cn.krain.springboot.model.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;@Controller@RequestMapping(\"/user\")public class UserController { //登录请求 @RequestMapping(value = \"/login\") @ResponseBody public String userLogin(HttpServletRequest request){ User user = new User(); user.setId(1001); user.setName(\"lisi\"); request.getSession().setAttribute(\"user\",user); //登录后将user对象放入到session中 return \"login success\"; } //无论用户登录与否都可以访问 @RequestMapping(value = \"/out\") @ResponseBody public String out(){ return \"anytime\"; } //用户登录后可访问 @RequestMapping(value = \"/detail\") @ResponseBody public String getDetail(){ return \"user detail\"; } //用户未登录时可以访问 @RequestMapping(value = \"/error\") @ResponseBody public String error(){ return \"error\"; }} User实体对象 12345678910111213141516171819202122package cn.krain.springboot.model;public class User { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 二、创建拦截器123456789101112131415161718192021222324252627282930313233343536package cn.krain.springboot.interceptor;import cn.krain.springboot.model.User;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class UserInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"====================进入拦截器====================\"); User user = (User) request.getSession().getAttribute(\"user\"); if (user == null){ response.sendRedirect(\"/user/error\"); //检测到用户未登录时，跳转到error界面 return false; } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} 三、创建拦截器配置类在项目中创建一个config包，创建一个配置类InterceptorConfig，并实现WebMvcConfigurer接口，覆盖接口中的addInterceptors方法，并为该配置类添加@Configuration注解，标注此类为一个配置类，让Spring Boot扫描到，这里的操作就相当于SpringMVC的注册拦截器，@Configuration 就相当于一个 applicationContext-mvc.xml文件。 123456789101112131415161718192021222324252627package cn.krain.springboot.config;import cn.krain.springboot.interceptor.UserInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configuration //用于定义配置类，相当于applicationContext-mvc.xml文件； // 定义一个拦截器，相当于之前的 mvc 里的配置public class InterceptorConfig implements WebMvcConfigurer { //所要拦截的请求路径 String[] addPathPatterns = { \"/user/**\" }; //不需要拦截的请求路径 String[] excludePathPatterns = { \"/user/login\",\"/user/error\",\"/user/out\" }; //mvc:interceptor class=\"\" @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new UserInterceptor()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns); }}","link":"/2021/03/24/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"SpringBoot集成Dubbo","text":"一、Dubbodubbo初体验，小白级入门案例 在SpringBoot中集成Dubbo，无需再写繁琐的xml配置文件，直接使用注解及其属性进行配置即可。 二、创建Interface、Provider、Consumer三个工程 interface工程只需要是一个普通的maven java工程即可，provider和consumer需要是SpringBoot工程。 ![image-20200824223346544](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824223346544.png) 三、在Provider、Consumer工程的pom文件中加入依赖 pom.xml 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--dubbo集成SpringBoot框架依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--注册中心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!--接口工程--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.krain.springboot&lt;/groupId&gt; &lt;artifactId&gt;019-springboot-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 四、代码实现 接口工程 在接口工程中只编写每个服务的接口文件。 1public interface DubboService { String addOneData(String str); } 服务提供者 在provider工程中，需要实现所有接口工程中的服务接口文件。 使用com.alibaba.dubbo.config.annotation.Service包中的注解@Service，interfaceClass属性用于指定接口文件类，version为版本号，timeout为时间限制。该注解的功能是代替了之前xml文件中的&lt;dubbo:service interface=&quot;&quot; version=&quot;&quot; ref=&quot;&quot; timeout=&quot;&quot;&gt;标签。 12345678910111213141516package cn.krain.springboot.service.impl;import cn.krain.springboot.service.DubboService;import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Component@Service(interfaceClass = DubboService.class, version = \"1.0.0\", timeout = 15000)//dubbo:servie interface=\"\" version=\"\" ref=\"\" timeout=\"\"public class DubboServiceImpl implements DubboService { @Override public String addOneData(String str) { return \"插入成功\"; }} 服务消费者 消费者工程需要编写控制层类。 12345678910111213141516171819202122package cn.krain.springboot.web;import cn.krain.springboot.service.DubboService;import com.alibaba.dubbo.config.annotation.Reference;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class DubboController { //dubbo:service interface=\"\" version=\"\" check=false @Reference(interfaceClass = DubboService.class, version = \"1.0.0\", check=false) private DubboService dubboService; @RequestMapping(value = \"/addStudent\") public @ResponseBody String add(String str){ String res = dubboService.addOneData(str); return str+res; }} 在SpringBoot主程序Application.java中，使用@EnableDubboConfiguration注解开启Dubbo配置。 1234567891011121314package cn.krain.springboot;import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication //开启spring配置@EnableDubboConfiguration //开启dubbo配置public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 五、启动程序 首先启动zookeeper。 ![image-20200824225711394](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824225711394.png) 启动服务提供者 启动服务消费者 发送请求 ![image-20200824230129867](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824230129867.png)","link":"/2021/03/24/SpringBoot%E9%9B%86%E6%88%90Dubbo/"},{"title":"使用Jedis对redis数据库操作","text":"一、运行环境该实例在maven中运行。 在pom文件中加入jedis依赖： 123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 二、代码实现 JedisPoolUtil文件：该文件用于创建JedisPoolConfig对象，通过该对象获取Jedis对象。 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.krain;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @author CC * @data 2020/8/14 - 15:52 */public class JedisPoolUtil { private static JedisPool pool = null; public static JedisPool getJedisPool(int port, String IP){ if (pool==null){ //创建JedisPoolConfig，给config设置连接池的参数，使用config对象创建JedisPool JedisPoolConfig config = new JedisPoolConfig(); //设置最大线程数，一个线程就是一个redis config.setMaxTotal(20); //设置最大空闲数 config.setMaxIdle(2); //设置检查为true，确保拿到的jedis是可用的 config.setTestOnBorrow(true); //创建pool对象 pool = new JedisPool(config, IP, port, 6000, \"123456\"); } return pool; } //关闭pool public static void close(){ if (pool!=null){ pool.close(); } }} JedisPoolTest文件：通过Jedis对redis数据库进行增删改查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package cn.krain;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import java.util.List;import java.util.Map;import java.util.Set;/** * @author CC * @data 2020/8/14 - 16:08 */public class JedisPoolTest { String IP = \"192.168.174.132\"; //redis所在服务器IP地址 int port = 6379; //端口号 JedisPool pool = JedisPoolUtil.getJedisPool(port, IP); Jedis jedis = null; @Test public void StringTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个String jedis.set(\"str1\",\"value1\"); String str1 = jedis.get(\"str1\"); Long num = jedis.strlen(\"str1\"); //获取指定key的字符长度 jedis.set(\"str2\",\"value2\"); List&lt;String&gt; strList = jedis.mget(\"str1\",\"str2\"); //一次获取多个string类型数据 System.out.println(\"str1=\"+str1); System.out.println(\"str1的长度为：\"+num); for(String str : strList){ System.out.println(str); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void HashTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个hash集合 jedis.hset(\"hash1\",\"k1\",\"v1\"); jedis.hset(\"hash1\",\"k2\",\"v2\"); jedis.hset(\"hash1\",\"k3\",\"v3\"); String k2 = jedis.hget(\"hash1\",\"k2\"); System.out.println(\"k2的值：\"+k2); Map&lt;String,String&gt; map = jedis.hgetAll(\"hash1\"); for (int i = 1; i &lt;= map.size(); i++) { System.out.println(map.get(\"k\"+i)); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void ListTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个list jedis.lpush(\"list1\",\"value1\", \"value2\", \"value3\"); //根据下表获取list中的值 String value = jedis.lindex(\"list1\", 1); System.out.println(value); }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void SetTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个set集合 jedis.sadd(\"set1\",\"value1\", \"value2\", \"value3\"); Long num = jedis.scard(\"set1\"); //统计set中数据的个数 System.out.println(\"set中数据的条数：\"+num); Set&lt;String&gt; set = jedis.smembers(\"set1\"); for(String str : set){ System.out.println(str); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void ZSetTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个ZSet jedis.zadd(\"zset1\",50,\"java\"); jedis.zadd(\"zset1\",30,\"mysql\"); jedis.zadd(\"zset1\",20,\"jsp\"); Set&lt;String&gt; set = jedis.zrange(\"zset1\",0,1); for(String str : set){ System.out.println(str); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } }}","link":"/2021/03/24/%E4%BD%BF%E7%94%A8Jedis%E5%AF%B9redis%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"title":"关闭和修改SpringBoot程序启动的logo","text":"一、SpringBoot程序启动默认logo![image-20200825105158509](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825105158509.png) 二、关闭logo修改SpringBoot主程序。 123456789101112131415161718192021package cn.krain.springboot;import org.springframework.boot.Banner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { //SpringApplication.run(Application.class, args); //获取入口Spring Boot类 SpringApplication springApplication = new SpringApplication(Application.class); //设置logo属性为关闭状态 springApplication.setBannerMode(Banner.Mode.OFF); springApplication.run(args); }} 三、修改logo在resources目录下创建一个banner.txt文件，文件名称必须是banner；然后在[获取logo网站]([http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20](http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type Something ))中获取指定文字的logo样式，复制粘贴到banner.txt文件中即可。 ![image-20200825105407113](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825105407113.png) 网站截图如下，可以选择字体的样式。 ![image-20200825105647879](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825105647879.png) ![image-20200825105732243](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825105732243.png) 运行程序结果如下：","link":"/2021/03/24/%E5%85%B3%E9%97%AD%E5%92%8C%E4%BF%AE%E6%94%B9SpringBoot%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%9A%84logo/"},{"title":"SpringBoot知识总结","text":"SpringBoot基础知识总结一、Spring Boot框架核心配置文件——application.propertiesapplication.properties可用于设置内嵌tomcat端口、设置上下文根（访问路径）、自定义参数、配置数据库连接信息、声明mapper文件路径等。 1234567891011121314151617181920212223# 一、用于设置内嵌tomcat端口server.port=8081# 二、用于设置上下文根（访问路径）server.servlet.context-path=/springboot# 三、自定义参数name=lisischool.name=zzulischool.website=www.zzuli.edu.cnstudent.name=zhangsanstudent.age=20# 四、配置数据库连接信息spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/user_testspring.datasource.name=rootspring.datasource.password=123456# 五、声明mapper文件路径（mapper文件与接口分开时）mybatis.mapper-locations=classpath:mapper/*.xml 二、yml与yaml文件yml与yaml文件，其功能与.properties文件功能相同，但是书写格式有所相同。 当.properties文件与.yml或.yaml文件同时出现时，Spring Boot会以.properties文件的优先级最高进行引用。 1234567891011121314151617# 设置tomcat端口及上下文根路径server: port: 8081 servlet: context-path: /yml# 四、配置数据库连接信息spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhsot:3306/user_test name: root password: 123456# 五、声明mapper文件路径（mapper文件与接口分开时）mybatis: mapper-locations: classpath:mapper/*.xml 三、自定义配置映射在application.properties文件中声明的参数，对于单个参数来说可以通过@Value注解的方式赋给指定变量，对于包含前缀的参数而言，需要使用Java对象，通过@Autowired注解进行变量的赋值。 12345678910111213141516171819202122232425262728package cn.krain.springboot.web;import cn.krain.springboot.config.School;import cn.krain.springboot.config.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class IndexController { @Value(\"${name}\") private String name; @Autowired private School school; @Autowired private Student student; @RequestMapping(\"/say\") @ResponseBody public String say(){ return \"school.name=\"+school.getName()+\" school.website=\"+school.getWebsite()+\"-----student.name=\"+student.getName()+\" student.age=\"+student.getAge(); }} 四、多环境下核心配置文件application.properties的使用在企业进行项目开发时，在开发阶段、测试阶段、正式发布阶段都会有对应的.properties文件，每个阶段的核心配置文件需要有严格的命名规则：application-dev.properties、application-test.properties、application-product.properties；然后在主配置文件中指定即可。 12# 等号后面的值为application-后的字符串product/dev/test；使用测试版时如下：spring.profiles.active=test 五、Spring Boot集成JSP 在pom文件中引入JSP依赖： 12345&lt;!--引入Springboot内嵌tomcat对jsp的解析依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 在main目录下创建webapp文件夹，并在Project Structure下指定该文件夹为web资源目录。 ![image-20200816211607412](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200816211607412.png) 点击OK，当webapp出现如下图标即成功。 ![image-20200816211737127](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200816211737127.png) 在application.properties文件中声明视图解析器 12spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp 六、Spring Boot集成Mybatis（Mybatis逆向工程） pom文件中加入mysql和mybatis-springboot依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 配置反向工程配置文件GeneratorMapper.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!-- 指定连接数据库的 JDBC 驱动包所在位置，指定到你本机的完整路径 --&gt; &lt;classPathEntry location=\"D:\\Program Files (x86)\\maven_work\\maven_repository\\mysql\\mysql-connector-java\\5.1.6\\mysql-connector-java-5.1.6.jar\"/&gt; &lt;!-- 配置 table 表信息内容体，targetRuntime 指定采用 MyBatis3 的版本 --&gt; &lt;context id=\"tables\" targetRuntime=\"MyBatis3\"&gt; &lt;!-- 抑制生成注释，由于生成的注释都是英文的，可以不让它生成 --&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/user_test\" userId=\"root\" password=\"123456\"&gt;&lt;/jdbcConnection&gt; &lt;!-- 生成 model 类，targetPackage 指定 model 类的包名，需要修改为自己的包目录， targetProject 指定 生成的 model 放在 eclipse 的哪个工程下面--&gt; &lt;javaModelGenerator targetPackage=\"cn.krain.springboot.model\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;property name=\"trimStrings\" value=\"false\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成 MyBatis 的 Mapper.xml 文件，targetPackage 指定 mapper.xml 文件的 包名，需要修改为自己的包目录， targetProject 指定生成的 mapper.xml 放在 eclipse 的哪个工程下面 --&gt; &lt;sqlMapGenerator targetPackage=\"cn.krain.springboot.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成 MyBatis 的 Mapper 接口类文件,targetPackage 指定 Mapper 接口类的包 名，需要修改为自己的包目录， targetProject 指定生成的 Mapper 接口放在 eclipse 的哪个工程下面 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.krain.springboot.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 数据库表名及对应的 Java 模型类名 --&gt; &lt;table tableName=\"t_student\" domainObjectName=\"Student\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 在application.properties中配置数据库连接信息 12345#配置数据库连接信息spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/user_testspring.datasource.name=rootspring.datasource.password=123456 在pom文件中加入Mybatis逆向工程插件 12345678910111213141516171819202122232425262728293031&lt;build&gt; &lt;!--指定编译时包含.xml文件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!--Mybatis逆向工程--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如果mapper文件位于resources目录下时，需要在application.properties文件下加入路径 12#声明mapper文件路径mybatis.mapper-locations=classpath:mapper/*.xml 七、注解式事务&emsp;&emsp;在springboot中，无需使用xml文件进行事务的配置，直接的指定方法上方加入@Transactional注解即可。 12345678@Transactional //事务注解@Overridepublic int editStudentById(Student student) { int i = studentMapper.updateByPrimaryKeySelective(student); return i;} 八、SpringBoot下SpringMVC的相关注解 Controller RestController RequestMapping GetMapping PostMapping DeleteMapping PutMapping …… 各自用法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.krain.springboot.web;import cn.krain.springboot.model.Student;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;//@Controller@RestController //相当于：控制层类上加@Controller + 方法上加@ResponseBody //意味着当前控制层类中所有方法返还的都是json对象public class StudentController { @RequestMapping(value = \"/student\") //@ResponseBody public Object getStudent(){ Student student = new Student(); student.setId(1001); student.setName(\"zhangsan\"); student.setAge(20); return student; } //该方法支持post和get请求方式 @RequestMapping(value = \"/studentDetail\", method = {RequestMethod.GET,RequestMethod.POST}) public Object getStudentDetail(){ Student student = new Student(); student.setId(1002); student.setName(\"lisi\"); student.setAge(26); return student; } //@RequestMapping(value = \"/queryStudent\", method = RequestMethod.GET) @GetMapping(value = \"queryStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在查询数据的时候使用 ——&gt; 查询 public Object queryStudent(){ return \"查询成功\"; } //@RequestMapping(value = \"/addStudent\", method = RequestMethod.POST) @PostMapping(value = \"addStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在新增数据的时候使用 ——&gt; 新增 public Object addStudent(){ return \"添加成功\"; } //@RequestMapping(value = \"/delStudent\", method = RequestMethod.DELETE) @DeleteMapping(value = \"delStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在删除数据的时候使用 ——&gt; 删除 public Object delStudent(){ return \"删除成功\"; } //@RequestMapping(value = \"/updateStudent\", method = RequestMethod.PUT) @PutMapping(value = \"updateStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在更新数据的时候使用 ——&gt; 更新 public Object updateStudent(){ return \"更新成功\"; }} 九、SpringBoot下实现Restful restful REST（英文：Representational State Transfer，简称 REST） 一种互联网软件架构设计的风格，但它并不是标准，它只是提出了一组客户端和服务器交互时的架构理念和设计原则，基于这种理念和原则设计的接口可以更简洁，更有层次，REST这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。 任何的技术都可以实现这种理念，如果一个架构符合 REST 原则，就称它为 RESTFul 架构。 比如我们要访问一个 http 接口：http://localhost:8080/boot/order?id=1021&amp;status=1 采用 RESTFul 风格则 http 地址为：http://localhost:8080/boot/order/1021/1 代码实现 在student1与student2两个方法中，都是从请求路径中获取id与name两个参数，但请求路不同。 12345678910111213141516171819202122232425262728package cn.krian.springboot.web;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.Map;@RestControllerpublic class Controller { @RequestMapping(value = \"/student/detail\") public Object student1(Integer id, String name){ Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student\"); map.put(\"id\",id); map.put(\"name\",name); return map; } @RequestMapping(value = \"/student/detail/{id}/{name}\") public Object student2(@PathVariable(\"id\") Integer id, @PathVariable(\"name\") String name){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student1\"); map.put(\"id\",id); map.put(\"name\",name); return map; }} 解决路径冲入问题 使用restful时，如果有某两个请求的参数个数相同，就会导致请求路径相同，此时需要加以区分。 方法一： 比如下面两个请求，虽然参数不同，但是个数相同，如果都将参数放到最后面，SpringMVC会无法区分，可通过调换参数位置加以区分。 1234567891011121314151617181920@RequestMapping(value = \"/student/detail/{id}/{name}\")public Object student1(@PathVariable(\"id\") Integer id, @PathVariable(\"name\") String name){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student1\"); map.put(\"id\",id); map.put(\"name\",name); return map;}//@RequestMapping(value = \"/student/detail/{id}/{state}\")@RequestMapping(value = \"/student/{id}/detail/{state}\")public Object student2(@PathVariable(\"id\") Integer id, @PathVariable(\"state\") String state){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student2\"); map.put(\"id\",id); map.put(\"state\",state); return map;} 方法二： 通过restful与增删改查注解相结合，来解决路径冲突的问题，如下代码所示。 12345678910111213141516171819@GetMapping(value = \"/student/detail/{id}/{age}\")public Object student3(@PathVariable(\"id\") Integer id, @PathVariable(\"age\") String age){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student3\"); map.put(\"id\",id); map.put(\"age\",age); return map;}@DeleteMapping(value = \"/student/detail/{id}/{status}\")public Object student4(@PathVariable(\"id\") Integer id, @PathVariable(\"status\") String status){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student4\"); map.put(\"id\",id); map.put(\"status\",status); return map;}","link":"/2021/03/24/SpringBoot%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"title":"SpringBoot模板引擎——Thymeleaf","text":"一、Thymeleaf简介Thymeleaf 是一个流行的模板引擎，该模板引擎采用 Java 语言开发 模板引擎是一个技术名词，是跨领域跨平台的概念，在 Java 语言体系下有模板引擎，在 C#、PHP 语言体系下也有模板引擎，甚至在 JavaScript 中也会用到模板引擎技术，Java 生态下的模板引擎有 Thymeleaf 、Freemaker、Velocity、Beetl（国产） 等。 Thymeleaf 对网络环境不存在严格的要求，既能用于 Web 环境下，也能用于非 Web 环境下。在非 Web 环境下，他能直接显示模板上的静态数据；在 Web 环境下，它能像 Jsp 一样从后台接收数据并替换掉模板上的静态数据。它是基于 HTML 的，以 HTML 标签为载体，Thymeleaf 要寄托在 HTML 标签下实现。 SpringBoot 集成了 Thymeleaf 模板技术，并且 Spring Boot 官方也推荐使用 Thymeleaf 来替代 JSP 技术，Thymeleaf 是另外的一种模板技术，它本身并不属于 Spring Boot，Spring Boot只是很好地集成这种模板技术，作为前端页面的数据展示，在过去的 Java Web 开发中，我们往往会选择使用 Jsp 去完成页面的动态渲染，但是 jsp 需要翻译编译运行，效率低 。 Thymeleaf 的官方网站：http://www.thymeleaf.org Thymeleaf 官方手册：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html 二、Thymeleaf 文件在SpringBoot项目中的位置位于resources目录下的templcates文件夹下。 ![image-20200825142541360](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825142541360.png) 三、使用Thymeleaf前提条件 创建SpringBoot项目是勾选Thymeleaf ![image-20200825144304325](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825144304325.png) 在html文件上方&lt;html lang=&quot;en&quot;&gt;加上xmlns:th=&quot;http://www.thymeleaf.org&quot; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;!-- xmlns:th=\"http://www.thymeleaf.org\" xmlns:是一个命名空间 地址是thymeleaf的规则文件--&gt;&lt;!-- 项目中包含thymeleaf依赖，他会根据thymeleaf自定义的标签名称， 获取后台数据--&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:text=\"${data}\"&gt;thymeleaf模板引擎&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 四、Thymeleaf表达式 标准表达式 1234&lt;h2&gt;thymeleaf标准表达式：${}&lt;/h2&gt;用户编号：&lt;h3 th:text=\"${user.id}\"&gt;&lt;/h3&gt;用户姓名：&lt;h3 th:text=\"${user.name}\"&gt;&lt;/h3&gt;用户住址：&lt;h3 th:text=\"${user.address}\"&gt;&lt;/h3&gt; 在控制层中，初始化了一个User对象，包含id、name、address属性，赋值后放入到Model中，在Thymeleaf页面中，直接使用标准表达式即可获取到数据。th:text是Thymeleaf的语法规则，表示表达式中的值会替代当前标签中的文本。 变量表达式（星号表达式） 123456&lt;h2&gt;thymeleaf变量表达式（星号表达式）：*{}&lt;/h2&gt;&lt;div th:object=\"${user}\"&gt; 用户编号：&lt;h3 th:text=\"*{id}\"&gt;&lt;/h3&gt; 用户姓名：&lt;h3 th:text=\"*{name}\"&gt;&lt;/h3&gt; 用户住址：&lt;h3 th:text=\"*{address}\"&gt;&lt;/h3&gt;&lt;/div&gt; 使用th:object表示${}是一个对象，在它的字标签中可以直接使用星号表达式——*{}，直接显示属性的值。 URL路径表达式 1234567891011121314151617181920212223242526272829&lt;h1&gt;URL路径表达式：@{......}&lt;/h1&gt;&lt;h2&gt;a标签中的绝对路径（无参数）：&lt;/h2&gt;&lt;a href=\"http://www.baidu.com\"&gt;传统方法跳转至百度&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{https://blog.csdn.net/ccccc_chuang}\"&gt;跳转至krain&lt;/a&gt;&lt;br&gt;&lt;a href=\"http://localhost:8080/user/detail\"&gt;传统方法跳转至/user/detail&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{http://localhost:8080/user/detail}\"&gt;跳转至/user/detail&lt;/a&gt;&lt;br&gt;&lt;h2&gt;相对路径（无参数）&lt;/h2&gt;&lt;a th:href=\"@{/user/detail}\"&gt;跳转至/user/detail&lt;/a&gt;&lt;br&gt;&lt;h2&gt;绝对路径（一个参数）&lt;/h2&gt;&lt;a href=\"http://localhost:8080/test?username=zhangsan\"&gt;绝对路径（带一个参数）&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{http://localhost:8080/test?username=zhangsan}\"&gt;相对路径（带一个参数）&lt;/a&gt;&lt;h2&gt;相对路径（一个参数）&lt;/h2&gt;&lt;a th:href=\"@{/test?username=zhangsan}\"&gt;相对路径（带一个参数）&lt;/a&gt;&lt;h2&gt;相对路径（从后台获取参数）&lt;/h2&gt;&lt;a th:href=\"@{'/test?username='+${name}}\"&gt;相对路径（带一个参数）&lt;/a&gt;&lt;h2&gt;相对路径（从后台获取参数）&lt;/h2&gt;&lt;a th:href=\"@{'/test1?id='+${id}+'&amp;username='+${name}+'&amp;address='+${address}}\"&gt;相对路径（从后台获取参数）&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{/test1(id=${id},username=${name},address=${address})}\"&gt;相对路径（从后台获取参数）,该方式推荐使用&lt;/a&gt;&lt;h2&gt;相对路径restful&lt;/h2&gt;&lt;a th:href=\"@{'/test3/'+${id}}\"&gt;相对路径restful1&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{'/test2/'+${id}+'/'+${name}}\"&gt;相对路径restful2&lt;/a&gt; 五、Thymeleaf常见属性 th:each=&quot;&quot;遍历Map、List、数组和混合型数据类型 后台控制类代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Controllerpublic class UserController { @RequestMapping(value = \"/each/list\") public String list(Model model){ List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); //List集合 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(\"100\"+i); user.setName(\"xxx\"+i); user.setAge(\"2\"+i); user.setAddress(\"河南\"+i); userList.add(user); } model.addAttribute(\"userList\",userList); return \"eachList\"; } @RequestMapping(value = \"/each/map\") public String map(Model model){ HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(); //Map集合 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(\"200\"+i); user.setName(\"yyy\"+i); user.setAge(\"3\"+i); user.setAddress(\"湖南\"+i); map.put(i,user); } model.addAttribute(\"userMap\",map); return \"eachMap\"; } @RequestMapping(value = \"/each/array\") public String array(Model model){ User[] users = new User[10]; //数组 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(\"300\"+i); user.setName(\"zzz\"+i); user.setAge(\"4\"+i); user.setAddress(\"海南\"+i); users[i] = user; } model.addAttribute(\"userArray\",users); return \"eachArray\"; } @RequestMapping(value = \"/each/all\") public String eachAll(Model model) { //list -&gt; Map -&gt; List -&gt; User list中嵌套Map，Map中又嵌套List，List中又嵌套User对象 List&lt;Map&lt;Integer, List&lt;User&gt;&gt;&gt; myList = new ArrayList&lt;Map&lt;Integer, List&lt;User&gt;&gt;&gt;(); for (int i = 0; i &lt; 2; i++) { Map&lt;Integer,List&lt;User&gt;&gt; myMap = new HashMap&lt;Integer, List&lt;User&gt;&gt;(); for (int j = 0; j &lt; 2; j++) { List&lt;User&gt; myUserList = new ArrayList&lt;User&gt;(); for (int k = 0; k &lt; 3; k++) { User user = new User(); user.setId(\"400\"+k); user.setName(\"张三\"+k); user.setAge(\"5\"+k); user.setAddress(\"广州市\"+i); myUserList.add(user); } myMap.put(j,myUserList); } myList.add(myMap); } model.addAttribute(\"myList\",myList); return \"eachAll\"; }} Thymeleaf代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;th:each 循环遍历数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;th:each 循环遍历 List 集合&lt;/h1&gt; &lt;div th:each=\"user,userStat:${userList}\"&gt; &lt;!-- userStat表示当前变量的状态 --&gt; &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt; &lt;!-- ${userStat.count}表示该List数据的个数 --&gt; &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt; &lt;!-- ${userStat.count}表示该List当前数据的下表 --&gt; &lt;span th:text=\"${user.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;h1&gt;th:each 循环遍历 Map 集合&lt;/h1&gt; &lt;div th:each=\"user,userStat:${userMap}\"&gt; &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.key}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;h1&gt;使用each遍历数组&lt;/h1&gt; &lt;div th:each=\"user,userStat:${userArray}\"&gt; &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;h1&gt;list -&gt; Map -&gt; List -&gt; User&lt;/h1&gt; &lt;div th:each=\"userMapList:${myList}\"&gt; &lt;div th:each=\"userListMap:${userMapList}\"&gt; Map集合的key：&lt;span th:text=\"${userListMap.key}\"&gt;&lt;/span&gt; &lt;div th:each=\"userList:${userListMap.value}\"&gt; &lt;span th:text=\"${userList.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userList.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userList.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userList.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 条件判断属性的使用 控制层 12345678910@Controllerpublic class JudgeController { @RequestMapping(value = \"/judge\") public String judge(Model model){ model.addAttribute(\"sex\",0); model.addAttribute(\"productType\",1); model.addAttribute(\"flag\",true); return \"condition\"; }} Thymeleaf 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;条件判断&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;th:if 条件判断&lt;/h2&gt; &lt;div th:if=\"${sex eq 1}\"&gt;男&lt;/div&gt; &lt;div th:if=\"${sex eq 0}\"&gt;女&lt;/div&gt; &lt;h2&gt;th:unless 与if相反&lt;/h2&gt; &lt;div th:unless=\"${sex ne 0}\"&gt;定一个flag&lt;/div&gt; &lt;div th:unless=\"${sex ne 1}\"&gt;定两个flag&lt;/div&gt; &lt;h2&gt;th:switch&lt;/h2&gt; &lt;div th:switch=\"${productType}\"&gt; &lt;span th:case=\"0\"&gt;产品0&lt;/span&gt; &lt;span th:case=\"1\"&gt;产品1&lt;/span&gt; &lt;span th:case=\"*\"&gt;无此产品&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 内敛表达式 12345678@Controllerpublic class InlineController { @RequestMapping(value = \"/inline\") public String inline(Model model){ model.addAttribute(\"data\", \"springboot data\"); return \"inline\"; }} 在标签中加入th:inline=&quot;text&quot;属性之后，直接可以在标签内使用[[${data}]]的方式显示后台数据。 在script标签中加入th:inline=&quot;javascript&quot;后，可以在脚本中使用[[${data}]]进行数据的显示。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内敛表达式&lt;/title&gt;&lt;/head&gt;&lt;body th:inline=\"text\"&gt; &lt;!--一般直接在body标签中加入--&gt; &lt;h1&gt; th:inline=\"text\" 内敛文本表达式&lt;/h1&gt; &lt;div th:inline=\"text\"&gt; 数据：[[${data}]] &lt;/div&gt; 数据out：[[${data}]] &lt;script type=\"text/javascript\" th:inline=\"javascript\"&gt; function showData() { alert([[${data}]]); alert(\"=====\"); } &lt;/script&gt; &lt;h1&gt;th:inline=\"javascript\" 内敛脚本表达式&lt;/h1&gt; &lt;div th:inline=\"javascript\"&gt; &lt;button onclick=\"showData()\"&gt;显示数据&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf运算符 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;数字运算&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 三元运算：表达式?”正确结果”:”错误结果” 算术运算：+ , - , * , / , % 关系比较：&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) 相等判断：== , != ( eq , ne ) --&gt; &lt;h1&gt;三元运算&lt;/h1&gt; &lt;span th:text=\"${sex eq 1 ? '男' : '女'}\"&gt;&lt;/span&gt; &lt;h1&gt;算术运算&lt;/h1&gt; 5-2=&lt;span th:text=\"5-2\"&gt;&lt;/span&gt;&lt;br/&gt; 5+2=&lt;span th:text=\"5+2\"&gt;&lt;/span&gt;&lt;br/&gt; 5*2=&lt;span th:text=\"5*2\"&gt;&lt;/span&gt;&lt;br/&gt; 5/2=&lt;span th:text=\"5/2\"&gt;&lt;/span&gt;&lt;br/&gt; 5%2=&lt;span th:text=\"5%2\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;h1&gt;关系比较&lt;/h1&gt; 5&gt;2为&lt;span th:if=\"${5 gt 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 5&lt;2为&lt;span th:unless=\"${5 lt 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 2&gt;=2为&lt;span th:if=\"${5 ge 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 2&lt;=2为&lt;span th:unless=\"${5 le 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; &lt;h1&gt;相等判断&lt;/h1&gt; 2==2为&lt;span th:if=\"${2 eq 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 5!=2为&lt;span th:if=\"${5 ne 2}\"&gt;真&lt;/span&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： ![image-20200825154808941](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825154808941.png) Thymeleaf基本对象 12345678910@Controllerpublic class BaseController { @RequestMapping(value = \"/baseObj\") public String baseObj(HttpServletRequest request, Model model, String id){ model.addAttribute(\"username\",\"lisi\"); request.getSession().setAttribute(\"data\",\"sessionData\"); return \"index\"; }} 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;基本表达式对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;从session中获取值的三种方法：&lt;/h1&gt; &lt;span th:text=\"${#session.getAttribute('data')}\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;span th:text=\"${#httpSession.getAttribute('data')}\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;span th:text=\"${session.data}\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" th:inline=\"javascript\"&gt; //获取协议名称 var scheme = [[${#request.getScheme()}]]; //http //获取服务器名称（IP地址） var serverName = [[${#request.getServerName()}]]; //localhost //获取服务器端口号 var serverPort = [[${#request.getServerPort()}]]; //8080 //获取上下文根路径 var contextPath = [[${#request.getContextPath()}]]; //springboot var allPath = scheme+\"://\"+serverName+\":\"+serverPort+contextPath; var requesrURL = [[${#httpServletRequest.requestURL}]]; var queryString = [[${#httpServletRequest.queryString}]]; alert(allPath); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf内置对象 12345678910@Controllerpublic class UserController { @RequestMapping(value = \"/user\") public String getUser(Model model){ model.addAttribute(\"data\",\"hello springboot\"); model.addAttribute(\"time\", new Date()); return \"user\"; }} 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 th:text=\"${time}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;h2 th:text=\"${#dates.format(time,'yyyy-MM-dd HH:mm:ss')}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;!--将时间格式化--&gt; &lt;h2 th:text=\"${data}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;h2 th:text=\"${#strings.substring(data,0,10)}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;!--获取该字符串的0~10位的子串--&gt; &lt;h2 th:text=\"${#lists}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;!--用于操作list数据类型--&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： ![image-20200825155347907](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200825155347907.png)","link":"/2021/03/24/SpringBoot%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94Thymeleaf/"},{"title":"Spring Boot集成Redis","text":"一、在pom文件中加入redis依赖12345&lt;!--springboot项目集称redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 二、启动Redis 三、关闭防火墙，使用图形界面工具连接到Redis数据库![image-20200824211945092](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824211945092.png) 四、在核心配置文件中配置Redis连接信息1234#配置redis数据库连接信息spring.redis.host=192.168.174.132spring.redis.port=6379spring.redis.password=123456 五、代码实现对Redis的获取和添加操作 RedisService 123456789101112131415public interface RedisService { /** * 新增key * @param key * @param value */ void addKey(String key, String value); /** * 通过key获取对应的value * @param key * @return */ String getValueByKey(String key);} RedisServiceImpl 123456789101112131415161718@Servicepublic class RedisServiceImpl implements RedisService { @Autowired private RedisTemplate&lt;Object, Object&gt; redisTemplate; //Spring自动注入RedisTemplate @Override public void addKey(String key, String value) { // 20: 表示该数据在缓存中存在的时间，TimeUnit.SECONDS为单位秒， // 20秒后缓存中的数据会自动消失 redisTemplate.opsForValue().set(key,value,20, TimeUnit.SECONDS); } @Override public String getValueByKey(String key) { return (String) redisTemplate.opsForValue().get(key); }} RedisController 123456789101112131415161718@RestControllerpublic class RedisController { @Autowired private RedisService redisService; @RequestMapping(value = \"/putRedis\") public String putString(String key, String value){ redisService.addKey(key,value); return \"操作redis成功(新增key)\"; } @RequestMapping(value = \"/getRedis\") public String getString(String key){ String str = redisService.getValueByKey(key); return \"key: \"+key+\" value:\"+str; }} 启动程序，在浏览器中发送增加key的请求： ![image-20200824214854629](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824214854629.png) 查看是否新增成功（由于我们设置的缓存是20s，即在20s之后，该值会自动在缓存中清除，这也是Redis效率高的原因所在）： ![image-20200824215045314](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824215045314.png) 从Redis缓存中获取数据： ![image-20200824215408766](D:\\Visio Studio Date\\blog_passage\\Typora-Image\\image-20200824215408766.png)","link":"/2021/03/24/Spring%20Boot%E9%9B%86%E6%88%90Redis/"}],"tags":[],"categories":[]}