{"pages":[],"posts":[{"title":"sql语句中参数的传递","text":"&emsp;&emsp;通过Mybatis的使用，开发人员只需要专心提供SQL语句即可，这篇文章介绍了SQL语句中参数传递的问题。大致有以下几种方式： 1. 单个参数传递123//在接口中定义放法，参数形式如下//使用单个参数Student selectById(int id); 123456789&lt;!-- 使用单个参数查询： parameterType：表示参数数据类型（可不写） 使用 #{参数名} 获取参数的值 对参数名称无要求--&gt;&lt;select id=\"selectById\" parameterType=\"int\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where id = #{id}&lt;/select&gt; 12//调用方法时只需要传入相应类型的单个值即可Student student = dao.selectById(2); 2. 使用@param为参数命名传递多个参数12345/* 在接口文件的对应方法形参中，使用以下格式进行命名* 多个参数：为参数命名，在形参前加上 @Param(\"自定义参数名\")* */List&lt;Student&gt; selectMultiParam(@Param(\"myname\") String name, @Param(\"myage\") Integer age); 12//调用时传入对应的参数值List&lt;Student&gt; students = dao.selectMultiParam(\"康康\",23); 123456&lt;!-- 多个参数：使用param命名 使用为参数起得名称 eg：#{命名}--&gt;&lt;select id=\"selectMultiParam\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{myname} or age=#{myage}&lt;/select&gt; 3. 使用Java对象作为方法的参数123//在接口中定义放法，参数形式如下//多个参数：使用java对象作为方法的参数List&lt;Student&gt; selectMultiObject(QueryParam queryParam); 12345678910&lt;!-- 多个参数：使用java对象的属性值作为参数实际值 原始语法：#{属性名, javaType=java中类型名称, jdbcType=数据库中的类型名} eg: #{queryName, javaType=String, jdbcType=Varchar} #{queryAge, javaType=Integer, jdbcType=Integer} 简写：#{属性名}--&gt;&lt;select id=\"selectMultiObject\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{queryName} or age=#{queryAge}&lt;/select&gt; 12//调用时传入相应对象List&lt;Student&gt; students = dao.selectMultiObject(queryParam); 4. 使用位置传参&emsp;&emsp;在方法的参数中，形参的顺序对应映射文件中参数的顺序，arg0指形参中第一个值，arg1代表第二个，以此类推。 123//在接口中定义放法，参数形式如下//多个参数：使用位置传参List&lt;Student&gt; selectMultiPosition(String name, Integer age); 1234&lt;!--根据参数位置传参 arg后面的数字代表参数所在的位置--&gt;&lt;select id=\"selectMultiPosition\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{arg0} or age=#{arg1}&lt;/select&gt; 12//调用代码List&lt;Student&gt; students = dao.selectMultiPosition(\"康康\", 23); 5. 使用map传参123//在接口中定义放法，参数形式如下//使用Map传递多个参数List&lt;Student&gt; selectMultiMap(Map&lt;String, Object&gt; map); 1234&lt;!--使用Map键值对传参，形式：#{key名}--&gt;&lt;select id=\"selectMultiMap\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where name=#{mapName} or age=#{mapAge}&lt;/select&gt; 12345//调用Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();data.put(\"mapName\",\"krain\");data.put(\"mapAge\",23);List&lt;Student&gt; students = dao.selectMultiMap(data);","link":"/2020/07/17/sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/16/hello-world/"},{"title":"SpringBoot中使用拦截器","text":"一、创建Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.krain.springboot.web;import cn.krain.springboot.model.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;@Controller@RequestMapping(\"/user\")public class UserController { //登录请求 @RequestMapping(value = \"/login\") @ResponseBody public String userLogin(HttpServletRequest request){ User user = new User(); user.setId(1001); user.setName(\"lisi\"); request.getSession().setAttribute(\"user\",user); //登录后将user对象放入到session中 return \"login success\"; } //无论用户登录与否都可以访问 @RequestMapping(value = \"/out\") @ResponseBody public String out(){ return \"anytime\"; } //用户登录后可访问 @RequestMapping(value = \"/detail\") @ResponseBody public String getDetail(){ return \"user detail\"; } //用户未登录时可以访问 @RequestMapping(value = \"/error\") @ResponseBody public String error(){ return \"error\"; }} User实体对象 12345678910111213141516171819202122package cn.krain.springboot.model;public class User { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }} 二、创建拦截器123456789101112131415161718192021222324252627282930313233343536package cn.krain.springboot.interceptor;import cn.krain.springboot.model.User;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class UserInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"====================进入拦截器====================\"); User user = (User) request.getSession().getAttribute(\"user\"); if (user == null){ response.sendRedirect(\"/user/error\"); //检测到用户未登录时，跳转到error界面 return false; } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} 三、创建拦截器配置类在项目中创建一个config包，创建一个配置类InterceptorConfig，并实现WebMvcConfigurer接口，覆盖接口中的addInterceptors方法，并为该配置类添加@Configuration注解，标注此类为一个配置类，让Spring Boot扫描到，这里的操作就相当于SpringMVC的注册拦截器，@Configuration 就相当于一个 applicationContext-mvc.xml文件。 123456789101112131415161718192021222324252627package cn.krain.springboot.config;import cn.krain.springboot.interceptor.UserInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configuration //用于定义配置类，相当于applicationContext-mvc.xml文件； // 定义一个拦截器，相当于之前的 mvc 里的配置public class InterceptorConfig implements WebMvcConfigurer { //所要拦截的请求路径 String[] addPathPatterns = { \"/user/**\" }; //不需要拦截的请求路径 String[] excludePathPatterns = { \"/user/login\",\"/user/error\",\"/user/out\" }; //mvc:interceptor class=\"\" @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new UserInterceptor()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns); }}","link":"/2021/03/24/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"SpringBoot集成Dubbo","text":"一、Dubbodubbo初体验，小白级入门案例 在SpringBoot中集成Dubbo，无需再写繁琐的xml配置文件，直接使用注解及其属性进行配置即可。 二、创建Interface、Provider、Consumer三个工程 interface工程只需要是一个普通的maven java工程即可，provider和consumer需要是SpringBoot工程。 三、在Provider、Consumer工程的pom文件中加入依赖 pom.xml 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--dubbo集成SpringBoot框架依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--注册中心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.11&lt;/version&gt; &lt;/dependency&gt; &lt;!--接口工程--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.krain.springboot&lt;/groupId&gt; &lt;artifactId&gt;019-springboot-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 四、代码实现 接口工程 在接口工程中只编写每个服务的接口文件。 1public interface DubboService { String addOneData(String str); } 服务提供者 在provider工程中，需要实现所有接口工程中的服务接口文件。 使用com.alibaba.dubbo.config.annotation.Service包中的注解@Service，interfaceClass属性用于指定接口文件类，version为版本号，timeout为时间限制。该注解的功能是代替了之前xml文件中的&lt;dubbo:service interface=&quot;&quot; version=&quot;&quot; ref=&quot;&quot; timeout=&quot;&quot;&gt;标签。 12345678910111213141516package cn.krain.springboot.service.impl;import cn.krain.springboot.service.DubboService;import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Component@Service(interfaceClass = DubboService.class, version = \"1.0.0\", timeout = 15000)//dubbo:servie interface=\"\" version=\"\" ref=\"\" timeout=\"\"public class DubboServiceImpl implements DubboService { @Override public String addOneData(String str) { return \"插入成功\"; }} 服务消费者 消费者工程需要编写控制层类。 12345678910111213141516171819202122package cn.krain.springboot.web;import cn.krain.springboot.service.DubboService;import com.alibaba.dubbo.config.annotation.Reference;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class DubboController { //dubbo:service interface=\"\" version=\"\" check=false @Reference(interfaceClass = DubboService.class, version = \"1.0.0\", check=false) private DubboService dubboService; @RequestMapping(value = \"/addStudent\") public @ResponseBody String add(String str){ String res = dubboService.addOneData(str); return str+res; }} 在SpringBoot主程序Application.java中，使用@EnableDubboConfiguration注解开启Dubbo配置。 1234567891011121314package cn.krain.springboot;import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication //开启spring配置@EnableDubboConfiguration //开启dubbo配置public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 五、启动程序 首先启动zookeeper。 启动服务提供者 启动服务消费者 发送请求","link":"/2021/03/24/SpringBoot%E9%9B%86%E6%88%90Dubbo/"},{"title":"使用Jedis对redis数据库操作","text":"一、运行环境该实例在maven中运行。 在pom文件中加入jedis依赖： 1234567&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;https://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedishttps://mvnrepository.com/artifact/redis.clients/jedis&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 二、代码实现 JedisPoolUtil文件：该文件用于创建JedisPoolConfig对象，通过该对象获取Jedis对象。 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.krain;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @author CC * @data 2020/8/14 - 15:52 */public class JedisPoolUtil { private static JedisPool pool = null; public static JedisPool getJedisPool(int port, String IP){ if (pool==null){ //创建JedisPoolConfig，给config设置连接池的参数，使用config对象创建JedisPool JedisPoolConfig config = new JedisPoolConfig(); //设置最大线程数，一个线程就是一个redis config.setMaxTotal(20); //设置最大空闲数 config.setMaxIdle(2); //设置检查为true，确保拿到的jedis是可用的 config.setTestOnBorrow(true); //创建pool对象 pool = new JedisPool(config, IP, port, 6000, \"123456\"); } return pool; } //关闭pool public static void close(){ if (pool!=null){ pool.close(); } }} JedisPoolTest文件：通过Jedis对redis数据库进行增删改查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package cn.krain;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import java.util.List;import java.util.Map;import java.util.Set;/** * @author CC * @data 2020/8/14 - 16:08 */public class JedisPoolTest { String IP = \"192.168.174.132\"; //redis所在服务器IP地址 int port = 6379; //端口号 JedisPool pool = JedisPoolUtil.getJedisPool(port, IP); Jedis jedis = null; @Test public void StringTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个String jedis.set(\"str1\",\"value1\"); String str1 = jedis.get(\"str1\"); Long num = jedis.strlen(\"str1\"); //获取指定key的字符长度 jedis.set(\"str2\",\"value2\"); List&lt;String&gt; strList = jedis.mget(\"str1\",\"str2\"); //一次获取多个string类型数据 System.out.println(\"str1=\"+str1); System.out.println(\"str1的长度为：\"+num); for(String str : strList){ System.out.println(str); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void HashTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个hash集合 jedis.hset(\"hash1\",\"k1\",\"v1\"); jedis.hset(\"hash1\",\"k2\",\"v2\"); jedis.hset(\"hash1\",\"k3\",\"v3\"); String k2 = jedis.hget(\"hash1\",\"k2\"); System.out.println(\"k2的值：\"+k2); Map&lt;String,String&gt; map = jedis.hgetAll(\"hash1\"); for (int i = 1; i &lt;= map.size(); i++) { System.out.println(map.get(\"k\"+i)); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void ListTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个list jedis.lpush(\"list1\",\"value1\", \"value2\", \"value3\"); //根据下表获取list中的值 String value = jedis.lindex(\"list1\", 1); System.out.println(value); }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void SetTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个set集合 jedis.sadd(\"set1\",\"value1\", \"value2\", \"value3\"); Long num = jedis.scard(\"set1\"); //统计set中数据的个数 System.out.println(\"set中数据的条数：\"+num); Set&lt;String&gt; set = jedis.smembers(\"set1\"); for(String str : set){ System.out.println(str); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } } @Test public void ZSetTest(){ try { //从pool中获取jedis对象 jedis = pool.getResource(); //初始化一个ZSet jedis.zadd(\"zset1\",50,\"java\"); jedis.zadd(\"zset1\",30,\"mysql\"); jedis.zadd(\"zset1\",20,\"jsp\"); Set&lt;String&gt; set = jedis.zrange(\"zset1\",0,1); for(String str : set){ System.out.println(str); } }finally { pool.close(); //关闭jedis，将获取的jedis放回到pool中 } }}","link":"/2021/03/24/%E4%BD%BF%E7%94%A8Jedis%E5%AF%B9redis%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"title":"关闭和修改SpringBoot程序启动的logo","text":"一、SpringBoot程序启动默认logo 二、关闭logo修改SpringBoot主程序。 123456789101112131415161718192021package cn.krain.springboot;import org.springframework.boot.Banner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application { public static void main(String[] args) { //SpringApplication.run(Application.class, args); //获取入口Spring Boot类 SpringApplication springApplication = new SpringApplication(Application.class); //设置logo属性为关闭状态 springApplication.setBannerMode(Banner.Mode.OFF); springApplication.run(args); }} 三、修改logo在resources目录下创建一个banner.txt文件，文件名称必须是banner；然后在获取logo网站中获取指定文字的logo样式，复制粘贴到banner.txt文件中即可。 网站截图如下，可以选择字体的样式。 运行程序结果如下：","link":"/2021/03/24/%E5%85%B3%E9%97%AD%E5%92%8C%E4%BF%AE%E6%94%B9SpringBoot%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%9A%84logo/"},{"title":"SpringBoot知识总结","text":"SpringBoot基础知识总结一、Spring Boot框架核心配置文件——application.propertiesapplication.properties可用于设置内嵌tomcat端口、设置上下文根（访问路径）、自定义参数、配置数据库连接信息、声明mapper文件路径等。 1234567891011121314151617181920212223# 一、用于设置内嵌tomcat端口server.port=8081# 二、用于设置上下文根（访问路径）server.servlet.context-path=/springboot# 三、自定义参数name=lisischool.name=zzulischool.website=www.zzuli.edu.cnstudent.name=zhangsanstudent.age=20# 四、配置数据库连接信息spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/user_testspring.datasource.name=rootspring.datasource.password=123456# 五、声明mapper文件路径（mapper文件与接口分开时）mybatis.mapper-locations=classpath:mapper/*.xml 二、yml与yaml文件yml与yaml文件，其功能与.properties文件功能相同，但是书写格式有所相同。 当.properties文件与.yml或.yaml文件同时出现时，Spring Boot会以.properties文件的优先级最高进行引用。 1234567891011121314151617# 设置tomcat端口及上下文根路径server: port: 8081 servlet: context-path: /yml# 四、配置数据库连接信息spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhsot:3306/user_test name: root password: 123456# 五、声明mapper文件路径（mapper文件与接口分开时）mybatis: mapper-locations: classpath:mapper/*.xml 三、自定义配置映射在application.properties文件中声明的参数，对于单个参数来说可以通过@Value注解的方式赋给指定变量，对于包含前缀的参数而言，需要使用Java对象，通过@Autowired注解进行变量的赋值。 12345678910111213141516171819202122232425262728package cn.krain.springboot.web;import cn.krain.springboot.config.School;import cn.krain.springboot.config.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class IndexController { @Value(\"${name}\") private String name; @Autowired private School school; @Autowired private Student student; @RequestMapping(\"/say\") @ResponseBody public String say(){ return \"school.name=\"+school.getName()+\" school.website=\"+school.getWebsite()+\"-----student.name=\"+student.getName()+\" student.age=\"+student.getAge(); }} 四、多环境下核心配置文件application.properties的使用在企业进行项目开发时，在开发阶段、测试阶段、正式发布阶段都会有对应的.properties文件，每个阶段的核心配置文件需要有严格的命名规则：application-dev.properties、application-test.properties、application-product.properties；然后在主配置文件中指定即可。 12# 等号后面的值为application-后的字符串product/dev/test；使用测试版时如下：spring.profiles.active=test 五、Spring Boot集成JSP 在pom文件中引入JSP依赖： 12345&lt;!--引入Springboot内嵌tomcat对jsp的解析依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 在main目录下创建webapp文件夹，并在Project Structure下指定该文件夹为web资源目录。 点击OK，当webapp出现如下图标即成功。 在application.properties文件中声明视图解析器 12spring.mvc.view.prefix=/spring.mvc.view.suffix=.jsp 六、Spring Boot集成Mybatis（Mybatis逆向工程） pom文件中加入mysql和mybatis-springboot依赖。 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 配置反向工程配置文件GeneratorMapper.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!-- 指定连接数据库的 JDBC 驱动包所在位置，指定到你本机的完整路径 --&gt; &lt;classPathEntry location=\"D:\\Program Files (x86)\\maven_work\\maven_repository\\mysql\\mysql-connector-java\\5.1.6\\mysql-connector-java-5.1.6.jar\"/&gt; &lt;!-- 配置 table 表信息内容体，targetRuntime 指定采用 MyBatis3 的版本 --&gt; &lt;context id=\"tables\" targetRuntime=\"MyBatis3\"&gt; &lt;!-- 抑制生成注释，由于生成的注释都是英文的，可以不让它生成 --&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/user_test\" userId=\"root\" password=\"123456\"&gt;&lt;/jdbcConnection&gt; &lt;!-- 生成 model 类，targetPackage 指定 model 类的包名，需要修改为自己的包目录， targetProject 指定 生成的 model 放在 eclipse 的哪个工程下面--&gt; &lt;javaModelGenerator targetPackage=\"cn.krain.springboot.model\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;property name=\"trimStrings\" value=\"false\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成 MyBatis 的 Mapper.xml 文件，targetPackage 指定 mapper.xml 文件的 包名，需要修改为自己的包目录， targetProject 指定生成的 mapper.xml 放在 eclipse 的哪个工程下面 --&gt; &lt;sqlMapGenerator targetPackage=\"cn.krain.springboot.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成 MyBatis 的 Mapper 接口类文件,targetPackage 指定 Mapper 接口类的包 名，需要修改为自己的包目录， targetProject 指定生成的 Mapper 接口放在 eclipse 的哪个工程下面 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.krain.springboot.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 数据库表名及对应的 Java 模型类名 --&gt; &lt;table tableName=\"t_student\" domainObjectName=\"Student\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 在application.properties中配置数据库连接信息 12345#配置数据库连接信息spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/user_testspring.datasource.name=rootspring.datasource.password=123456 在pom文件中加入Mybatis逆向工程插件 12345678910111213141516171819202122232425262728293031&lt;build&gt; &lt;!--指定编译时包含.xml文件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!--Mybatis逆向工程--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如果mapper文件位于resources目录下时，需要在application.properties文件下加入路径 12#声明mapper文件路径mybatis.mapper-locations=classpath:mapper/*.xml 七、注解式事务&emsp;&emsp;在springboot中，无需使用xml文件进行事务的配置，直接的指定方法上方加入@Transactional注解即可。 12345678@Transactional //事务注解@Overridepublic int editStudentById(Student student) { int i = studentMapper.updateByPrimaryKeySelective(student); return i;} 八、SpringBoot下SpringMVC的相关注解 Controller RestController RequestMapping GetMapping PostMapping DeleteMapping PutMapping …… 各自用法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.krain.springboot.web;import cn.krain.springboot.model.Student;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;//@Controller@RestController //相当于：控制层类上加@Controller + 方法上加@ResponseBody //意味着当前控制层类中所有方法返还的都是json对象public class StudentController { @RequestMapping(value = \"/student\") //@ResponseBody public Object getStudent(){ Student student = new Student(); student.setId(1001); student.setName(\"zhangsan\"); student.setAge(20); return student; } //该方法支持post和get请求方式 @RequestMapping(value = \"/studentDetail\", method = {RequestMethod.GET,RequestMethod.POST}) public Object getStudentDetail(){ Student student = new Student(); student.setId(1002); student.setName(\"lisi\"); student.setAge(26); return student; } //@RequestMapping(value = \"/queryStudent\", method = RequestMethod.GET) @GetMapping(value = \"queryStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在查询数据的时候使用 ——&gt; 查询 public Object queryStudent(){ return \"查询成功\"; } //@RequestMapping(value = \"/addStudent\", method = RequestMethod.POST) @PostMapping(value = \"addStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在新增数据的时候使用 ——&gt; 新增 public Object addStudent(){ return \"添加成功\"; } //@RequestMapping(value = \"/delStudent\", method = RequestMethod.DELETE) @DeleteMapping(value = \"delStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在删除数据的时候使用 ——&gt; 删除 public Object delStudent(){ return \"删除成功\"; } //@RequestMapping(value = \"/updateStudent\", method = RequestMethod.PUT) @PutMapping(value = \"updateStudent\") //该注解功能相当于上一行代码，如果请求方式不对会报405错误 //该注解在更新数据的时候使用 ——&gt; 更新 public Object updateStudent(){ return \"更新成功\"; }} 九、SpringBoot下实现Restful restful REST（英文：Representational State Transfer，简称 REST） 一种互联网软件架构设计的风格，但它并不是标准，它只是提出了一组客户端和服务器交互时的架构理念和设计原则，基于这种理念和原则设计的接口可以更简洁，更有层次，REST这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。 任何的技术都可以实现这种理念，如果一个架构符合 REST 原则，就称它为 RESTFul 架构。 比如我们要访问一个 http 接口：http://localhost:8080/boot/order?id=1021&amp;status=1 采用 RESTFul 风格则 http 地址为：http://localhost:8080/boot/order/1021/1 代码实现 在student1与student2两个方法中，都是从请求路径中获取id与name两个参数，但请求路不同。 12345678910111213141516171819202122232425262728package cn.krian.springboot.web;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.Map;@RestControllerpublic class Controller { @RequestMapping(value = \"/student/detail\") public Object student1(Integer id, String name){ Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student\"); map.put(\"id\",id); map.put(\"name\",name); return map; } @RequestMapping(value = \"/student/detail/{id}/{name}\") public Object student2(@PathVariable(\"id\") Integer id, @PathVariable(\"name\") String name){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student1\"); map.put(\"id\",id); map.put(\"name\",name); return map; }} 解决路径冲入问题 使用restful时，如果有某两个请求的参数个数相同，就会导致请求路径相同，此时需要加以区分。 方法一： 比如下面两个请求，虽然参数不同，但是个数相同，如果都将参数放到最后面，SpringMVC会无法区分，可通过调换参数位置加以区分。 1234567891011121314151617181920@RequestMapping(value = \"/student/detail/{id}/{name}\")public Object student1(@PathVariable(\"id\") Integer id, @PathVariable(\"name\") String name){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student1\"); map.put(\"id\",id); map.put(\"name\",name); return map;}//@RequestMapping(value = \"/student/detail/{id}/{state}\")@RequestMapping(value = \"/student/{id}/detail/{state}\")public Object student2(@PathVariable(\"id\") Integer id, @PathVariable(\"state\") String state){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student2\"); map.put(\"id\",id); map.put(\"state\",state); return map;} 方法二： 通过restful与增删改查注解相结合，来解决路径冲突的问题，如下代码所示。 12345678910111213141516171819@GetMapping(value = \"/student/detail/{id}/{age}\")public Object student3(@PathVariable(\"id\") Integer id, @PathVariable(\"age\") String age){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student3\"); map.put(\"id\",id); map.put(\"age\",age); return map;}@DeleteMapping(value = \"/student/detail/{id}/{status}\")public Object student4(@PathVariable(\"id\") Integer id, @PathVariable(\"status\") String status){ HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"title\",\"student4\"); map.put(\"id\",id); map.put(\"status\",status); return map;}","link":"/2021/03/24/SpringBoot%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"title":"SpringBoot模板引擎——Thymeleaf","text":"一、Thymeleaf简介Thymeleaf 是一个流行的模板引擎，该模板引擎采用 Java 语言开发 模板引擎是一个技术名词，是跨领域跨平台的概念，在 Java 语言体系下有模板引擎，在 C#、PHP 语言体系下也有模板引擎，甚至在 JavaScript 中也会用到模板引擎技术，Java 生态下的模板引擎有 Thymeleaf 、Freemaker、Velocity、Beetl（国产） 等。 Thymeleaf 对网络环境不存在严格的要求，既能用于 Web 环境下，也能用于非 Web 环境下。在非 Web 环境下，他能直接显示模板上的静态数据；在 Web 环境下，它能像 Jsp 一样从后台接收数据并替换掉模板上的静态数据。它是基于 HTML 的，以 HTML 标签为载体，Thymeleaf 要寄托在 HTML 标签下实现。 SpringBoot 集成了 Thymeleaf 模板技术，并且 Spring Boot 官方也推荐使用 Thymeleaf 来替代 JSP 技术，Thymeleaf 是另外的一种模板技术，它本身并不属于 Spring Boot，Spring Boot只是很好地集成这种模板技术，作为前端页面的数据展示，在过去的 Java Web 开发中，我们往往会选择使用 Jsp 去完成页面的动态渲染，但是 jsp 需要翻译编译运行，效率低 。 Thymeleaf 的官方网站：http://www.thymeleaf.org Thymeleaf 官方手册：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html 二、Thymeleaf 文件在SpringBoot项目中的位置位于resources目录下的templcates文件夹下。 三、使用Thymeleaf前提条件 创建SpringBoot项目是勾选Thymeleaf 在html文件上方&lt;html lang=&quot;en&quot;&gt;加上xmlns:th=&quot;http://www.thymeleaf.org&quot; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;!-- xmlns:th=\"http://www.thymeleaf.org\" xmlns:是一个命名空间 地址是thymeleaf的规则文件--&gt;&lt;!-- 项目中包含thymeleaf依赖，他会根据thymeleaf自定义的标签名称， 获取后台数据--&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:text=\"${data}\"&gt;thymeleaf模板引擎&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 四、Thymeleaf表达式 标准表达式 1234&lt;h2&gt;thymeleaf标准表达式：${}&lt;/h2&gt;用户编号：&lt;h3 th:text=\"${user.id}\"&gt;&lt;/h3&gt;用户姓名：&lt;h3 th:text=\"${user.name}\"&gt;&lt;/h3&gt;用户住址：&lt;h3 th:text=\"${user.address}\"&gt;&lt;/h3&gt; 在控制层中，初始化了一个User对象，包含id、name、address属性，赋值后放入到Model中，在Thymeleaf页面中，直接使用标准表达式即可获取到数据。th:text是Thymeleaf的语法规则，表示表达式中的值会替代当前标签中的文本。 变量表达式（星号表达式） 123456&lt;h2&gt;thymeleaf变量表达式（星号表达式）：*{}&lt;/h2&gt;&lt;div th:object=\"${user}\"&gt; 用户编号：&lt;h3 th:text=\"*{id}\"&gt;&lt;/h3&gt; 用户姓名：&lt;h3 th:text=\"*{name}\"&gt;&lt;/h3&gt; 用户住址：&lt;h3 th:text=\"*{address}\"&gt;&lt;/h3&gt;&lt;/div&gt; 使用th:object表示${}是一个对象，在它的字标签中可以直接使用星号表达式——*{}，直接显示属性的值。 URL路径表达式 1234567891011121314151617181920212223242526272829&lt;h1&gt;URL路径表达式：@{......}&lt;/h1&gt;&lt;h2&gt;a标签中的绝对路径（无参数）：&lt;/h2&gt;&lt;a href=\"http://www.baidu.com\"&gt;传统方法跳转至百度&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{https://blog.csdn.net/ccccc_chuang}\"&gt;跳转至krain&lt;/a&gt;&lt;br&gt;&lt;a href=\"http://localhost:8080/user/detail\"&gt;传统方法跳转至/user/detail&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{http://localhost:8080/user/detail}\"&gt;跳转至/user/detail&lt;/a&gt;&lt;br&gt;&lt;h2&gt;相对路径（无参数）&lt;/h2&gt;&lt;a th:href=\"@{/user/detail}\"&gt;跳转至/user/detail&lt;/a&gt;&lt;br&gt;&lt;h2&gt;绝对路径（一个参数）&lt;/h2&gt;&lt;a href=\"http://localhost:8080/test?username=zhangsan\"&gt;绝对路径（带一个参数）&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{http://localhost:8080/test?username=zhangsan}\"&gt;相对路径（带一个参数）&lt;/a&gt;&lt;h2&gt;相对路径（一个参数）&lt;/h2&gt;&lt;a th:href=\"@{/test?username=zhangsan}\"&gt;相对路径（带一个参数）&lt;/a&gt;&lt;h2&gt;相对路径（从后台获取参数）&lt;/h2&gt;&lt;a th:href=\"@{'/test?username='+${name}}\"&gt;相对路径（带一个参数）&lt;/a&gt;&lt;h2&gt;相对路径（从后台获取参数）&lt;/h2&gt;&lt;a th:href=\"@{'/test1?id='+${id}+'&amp;username='+${name}+'&amp;address='+${address}}\"&gt;相对路径（从后台获取参数）&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{/test1(id=${id},username=${name},address=${address})}\"&gt;相对路径（从后台获取参数）,该方式推荐使用&lt;/a&gt;&lt;h2&gt;相对路径restful&lt;/h2&gt;&lt;a th:href=\"@{'/test3/'+${id}}\"&gt;相对路径restful1&lt;/a&gt;&lt;br&gt; &lt;!-- 与下一行代码功能相同 --&gt;&lt;a th:href=\"@{'/test2/'+${id}+'/'+${name}}\"&gt;相对路径restful2&lt;/a&gt; 五、Thymeleaf常见属性 th:each=&quot;&quot;遍历Map、List、数组和混合型数据类型 后台控制类代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Controllerpublic class UserController { @RequestMapping(value = \"/each/list\") public String list(Model model){ List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); //List集合 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(\"100\"+i); user.setName(\"xxx\"+i); user.setAge(\"2\"+i); user.setAddress(\"河南\"+i); userList.add(user); } model.addAttribute(\"userList\",userList); return \"eachList\"; } @RequestMapping(value = \"/each/map\") public String map(Model model){ HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(); //Map集合 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(\"200\"+i); user.setName(\"yyy\"+i); user.setAge(\"3\"+i); user.setAddress(\"湖南\"+i); map.put(i,user); } model.addAttribute(\"userMap\",map); return \"eachMap\"; } @RequestMapping(value = \"/each/array\") public String array(Model model){ User[] users = new User[10]; //数组 for (int i = 0; i &lt; 10; i++) { User user = new User(); user.setId(\"300\"+i); user.setName(\"zzz\"+i); user.setAge(\"4\"+i); user.setAddress(\"海南\"+i); users[i] = user; } model.addAttribute(\"userArray\",users); return \"eachArray\"; } @RequestMapping(value = \"/each/all\") public String eachAll(Model model) { //list -&gt; Map -&gt; List -&gt; User list中嵌套Map，Map中又嵌套List，List中又嵌套User对象 List&lt;Map&lt;Integer, List&lt;User&gt;&gt;&gt; myList = new ArrayList&lt;Map&lt;Integer, List&lt;User&gt;&gt;&gt;(); for (int i = 0; i &lt; 2; i++) { Map&lt;Integer,List&lt;User&gt;&gt; myMap = new HashMap&lt;Integer, List&lt;User&gt;&gt;(); for (int j = 0; j &lt; 2; j++) { List&lt;User&gt; myUserList = new ArrayList&lt;User&gt;(); for (int k = 0; k &lt; 3; k++) { User user = new User(); user.setId(\"400\"+k); user.setName(\"张三\"+k); user.setAge(\"5\"+k); user.setAddress(\"广州市\"+i); myUserList.add(user); } myMap.put(j,myUserList); } myList.add(myMap); } model.addAttribute(\"myList\",myList); return \"eachAll\"; }} Thymeleaf代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;th:each 循环遍历数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;th:each 循环遍历 List 集合&lt;/h1&gt; &lt;div th:each=\"user,userStat:${userList}\"&gt; &lt;!-- userStat表示当前变量的状态 --&gt; &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt; &lt;!-- ${userStat.count}表示该List数据的个数 --&gt; &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt; &lt;!-- ${userStat.count}表示该List当前数据的下表 --&gt; &lt;span th:text=\"${user.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;h1&gt;th:each 循环遍历 Map 集合&lt;/h1&gt; &lt;div th:each=\"user,userStat:${userMap}\"&gt; &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.key}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.value.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;h1&gt;使用each遍历数组&lt;/h1&gt; &lt;div th:each=\"user,userStat:${userArray}\"&gt; &lt;span th:text=\"${userStat.index}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userStat.count}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${user.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;h1&gt;list -&gt; Map -&gt; List -&gt; User&lt;/h1&gt; &lt;div th:each=\"userMapList:${myList}\"&gt; &lt;div th:each=\"userListMap:${userMapList}\"&gt; Map集合的key：&lt;span th:text=\"${userListMap.key}\"&gt;&lt;/span&gt; &lt;div th:each=\"userList:${userListMap.value}\"&gt; &lt;span th:text=\"${userList.id}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userList.name}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userList.age}\"&gt;&lt;/span&gt; &lt;span th:text=\"${userList.address}\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 条件判断属性的使用 控制层 12345678910@Controllerpublic class JudgeController { @RequestMapping(value = \"/judge\") public String judge(Model model){ model.addAttribute(\"sex\",0); model.addAttribute(\"productType\",1); model.addAttribute(\"flag\",true); return \"condition\"; }} Thymeleaf 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;条件判断&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;th:if 条件判断&lt;/h2&gt; &lt;div th:if=\"${sex eq 1}\"&gt;男&lt;/div&gt; &lt;div th:if=\"${sex eq 0}\"&gt;女&lt;/div&gt; &lt;h2&gt;th:unless 与if相反&lt;/h2&gt; &lt;div th:unless=\"${sex ne 0}\"&gt;定一个flag&lt;/div&gt; &lt;div th:unless=\"${sex ne 1}\"&gt;定两个flag&lt;/div&gt; &lt;h2&gt;th:switch&lt;/h2&gt; &lt;div th:switch=\"${productType}\"&gt; &lt;span th:case=\"0\"&gt;产品0&lt;/span&gt; &lt;span th:case=\"1\"&gt;产品1&lt;/span&gt; &lt;span th:case=\"*\"&gt;无此产品&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 内敛表达式 12345678@Controllerpublic class InlineController { @RequestMapping(value = \"/inline\") public String inline(Model model){ model.addAttribute(\"data\", \"springboot data\"); return \"inline\"; }} 在标签中加入th:inline=&quot;text&quot;属性之后，直接可以在标签内使用[[${data}]]的方式显示后台数据。 在script标签中加入th:inline=&quot;javascript&quot;后，可以在脚本中使用[[${data}]]进行数据的显示。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内敛表达式&lt;/title&gt;&lt;/head&gt;&lt;body th:inline=\"text\"&gt; &lt;!--一般直接在body标签中加入--&gt; &lt;h1&gt; th:inline=\"text\" 内敛文本表达式&lt;/h1&gt; &lt;div th:inline=\"text\"&gt; 数据：[[${data}]] &lt;/div&gt; 数据out：[[${data}]] &lt;script type=\"text/javascript\" th:inline=\"javascript\"&gt; function showData() { alert([[${data}]]); alert(\"=====\"); } &lt;/script&gt; &lt;h1&gt;th:inline=\"javascript\" 内敛脚本表达式&lt;/h1&gt; &lt;div th:inline=\"javascript\"&gt; &lt;button onclick=\"showData()\"&gt;显示数据&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf运算符 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;数字运算&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 三元运算：表达式?”正确结果”:”错误结果” 算术运算：+ , - , * , / , % 关系比较：&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) 相等判断：== , != ( eq , ne ) --&gt; &lt;h1&gt;三元运算&lt;/h1&gt; &lt;span th:text=\"${sex eq 1 ? '男' : '女'}\"&gt;&lt;/span&gt; &lt;h1&gt;算术运算&lt;/h1&gt; 5-2=&lt;span th:text=\"5-2\"&gt;&lt;/span&gt;&lt;br/&gt; 5+2=&lt;span th:text=\"5+2\"&gt;&lt;/span&gt;&lt;br/&gt; 5*2=&lt;span th:text=\"5*2\"&gt;&lt;/span&gt;&lt;br/&gt; 5/2=&lt;span th:text=\"5/2\"&gt;&lt;/span&gt;&lt;br/&gt; 5%2=&lt;span th:text=\"5%2\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;h1&gt;关系比较&lt;/h1&gt; 5&gt;2为&lt;span th:if=\"${5 gt 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 5&lt;2为&lt;span th:unless=\"${5 lt 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 2&gt;=2为&lt;span th:if=\"${5 ge 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 2&lt;=2为&lt;span th:unless=\"${5 le 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; &lt;h1&gt;相等判断&lt;/h1&gt; 2==2为&lt;span th:if=\"${2 eq 2}\"&gt;真&lt;/span&gt;&lt;br/&gt; 5!=2为&lt;span th:if=\"${5 ne 2}\"&gt;真&lt;/span&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： Thymeleaf基本对象 12345678910@Controllerpublic class BaseController { @RequestMapping(value = \"/baseObj\") public String baseObj(HttpServletRequest request, Model model, String id){ model.addAttribute(\"username\",\"lisi\"); request.getSession().setAttribute(\"data\",\"sessionData\"); return \"index\"; }} 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;基本表达式对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;从session中获取值的三种方法：&lt;/h1&gt; &lt;span th:text=\"${#session.getAttribute('data')}\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;span th:text=\"${#httpSession.getAttribute('data')}\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;span th:text=\"${session.data}\"&gt;&lt;/span&gt;&lt;br/&gt; &lt;script type=\"text/javascript\" th:inline=\"javascript\"&gt; //获取协议名称 var scheme = [[${#request.getScheme()}]]; //http //获取服务器名称（IP地址） var serverName = [[${#request.getServerName()}]]; //localhost //获取服务器端口号 var serverPort = [[${#request.getServerPort()}]]; //8080 //获取上下文根路径 var contextPath = [[${#request.getContextPath()}]]; //springboot var allPath = scheme+\"://\"+serverName+\":\"+serverPort+contextPath; var requesrURL = [[${#httpServletRequest.requestURL}]]; var queryString = [[${#httpServletRequest.queryString}]]; alert(allPath); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf内置对象 12345678910@Controllerpublic class UserController { @RequestMapping(value = \"/user\") public String getUser(Model model){ model.addAttribute(\"data\",\"hello springboot\"); model.addAttribute(\"time\", new Date()); return \"user\"; }} 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 th:text=\"${time}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;h2 th:text=\"${#dates.format(time,'yyyy-MM-dd HH:mm:ss')}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;!--将时间格式化--&gt; &lt;h2 th:text=\"${data}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;h2 th:text=\"${#strings.substring(data,0,10)}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;!--获取该字符串的0~10位的子串--&gt; &lt;h2 th:text=\"${#lists}\"&gt;&lt;/h2&gt;&lt;br/&gt; &lt;!--用于操作list数据类型--&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：","link":"/2021/03/24/SpringBoot%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94Thymeleaf/"},{"title":"Spring Boot集成Redis","text":"一、在pom文件中加入redis依赖12345&lt;!--springboot项目集称redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 二、启动Redis 三、关闭防火墙，使用图形界面工具连接到Redis数据库 四、在核心配置文件中配置Redis连接信息1234#配置redis数据库连接信息spring.redis.host=192.168.174.132spring.redis.port=6379spring.redis.password=123456 五、代码实现对Redis的获取和添加操作 RedisService 123456789101112131415public interface RedisService { /** * 新增key * @param key * @param value */ void addKey(String key, String value); /** * 通过key获取对应的value * @param key * @return */ String getValueByKey(String key);} RedisServiceImpl 123456789101112131415161718@Servicepublic class RedisServiceImpl implements RedisService { @Autowired private RedisTemplate&lt;Object, Object&gt; redisTemplate; //Spring自动注入RedisTemplate @Override public void addKey(String key, String value) { // 20: 表示该数据在缓存中存在的时间，TimeUnit.SECONDS为单位秒， // 20秒后缓存中的数据会自动消失 redisTemplate.opsForValue().set(key,value,20, TimeUnit.SECONDS); } @Override public String getValueByKey(String key) { return (String) redisTemplate.opsForValue().get(key); }} RedisController 123456789101112131415161718@RestControllerpublic class RedisController { @Autowired private RedisService redisService; @RequestMapping(value = \"/putRedis\") public String putString(String key, String value){ redisService.addKey(key,value); return \"操作redis成功(新增key)\"; } @RequestMapping(value = \"/getRedis\") public String getString(String key){ String str = redisService.getValueByKey(key); return \"key: \"+key+\" value:\"+str; }} 启动程序，在浏览器中发送增加key的请求： 查看是否新增成功（由于我们设置的缓存是20s，即在20s之后，该值会自动在缓存中清除，这也是Redis效率高的原因所在）： 从Redis缓存中获取数据：","link":"/2021/03/24/Spring%20Boot%E9%9B%86%E6%88%90Redis/"},{"title":"spring事务处理","text":"一、事务&emsp;&emsp;以涉及多个数据库表的操作为例，事务是指一组sql语句的集合， 集合中有多条sql语句可能是insert，update，select，delete，我们希望这些多个sql语句都能成功，或者都失败，这些sql语句的执行是一致的，作为一个整体执行。 &emsp;&emsp;由于不同数据库的访问技术，有不同的事务处理的机制，对象，方法。Spring提供一种处理事务的统一模型，能使用统一步骤和方式完成多种不同数据库访问技术的事务处理。 二、如何实现事务处理spring处理事务的模型，使用的步骤都是固定的，把事务处理所使用的信息提供给spring就可以了。 1、事务内部提交，回滚事务，使用事务管理器对象，代替开发人员完成commit，rollback事务管理器是一个接口和他的众多实现类。 接口：PlatformTransactionManager，定义了事务重要方法 commit ，rollback. 实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。 2、根据业务方法需要的事务，说明需要事务的类型。1）事务的隔离级别：有4个值 DEFAULT：采用 DB 默认的事务隔离级别。MySql 的默认为 REPEATABLE_READ； Oracle默认为 READ_COMMITTED。 READ_UNCOMMITTED：读未提交。未解决任何并发问题。 READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。 REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读 SERIALIZABLE：串行化。不存在并发问题。 2）事务的超时时间： 表示一个方法最长的执行时间，如果方法执行时超过了时间，事务就回滚。单位是秒，整数值，默认是-1 3）事务的传播行为：控制业务方法是不是有事务的，是什么样的事务的 7个传播行为，表示在业务方法调用时，事务在方法之间是如何使用的： PROPAGATION_REQUIRED PROPAGATION_REQUIRES_NEW PROPAGATION_SUPPORTS PROPAGATION_MANDATORY PROPAGATION_NESTED PROPAGATION_NEVER PROPAGATION_NOT_SUPPORTED3、提交事务，回滚事务的时机1）当业务方法，执行成功，没有异常抛出，当方法执行完毕，spring在方法执行后提交事务。事务管理器commit 2）当业务方法抛出运行时异常或ERROR，spring执行回滚，调用事务管理器的rollback 3）当业务方法抛出非运行时异常，主要是受查异常时，提交事务 三、实现事务处理的方式1、@Transactional注解步骤： 声明事务管理器对象 &lt;bean id=&quot;xx&quot; class=&quot;DataSourceTransactionManager&quot;&gt; 开启事务注解驱动，告诉Spring框架，我要使用注解的方式管理事务。 Spring使用aop机制，创建@Transactional所在的类代理对象，给方法加入事务的功能。 spring给业务方法加入事务：在你的业务方法执行之前，先开启事务，在业务方法之后提交或回滚事务，使用aop的环绕通知： @Around(&quot;你要增加的事务功能的业务方法名称&quot;) Object myAround(){ Spring为我们开启开启事务 try{ buy(1001,10); //执行方法及参数 spring的事务管理器.commit(); }catch(Exception e){ spring的事务管理器.rollback(); } } 在执行方法的上面加入@Trancational 2、Aspectj框架功能在spring配置文件中声明类，方法需要的事务。这种方式业务方法和事务配置完全分离。 实现步骤：都是在xml配置文件中实现。 1）要使用的是aspectj框架，需要加入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2）声明事务管理器对象 1&lt;bean id=\"xx\" class=\"DataSourceTransactionManager\"&gt; 3）声明方法需要的事务类型（配置方法的事务属性【隔离级别，传播行为，超时】） 4）配置aop：指定哪些类要创建代理。","link":"/2021/04/23/spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"},{"title":"初识spring","text":"1、Spring框架简介&emsp;&emsp;Spring出现在2002年左右，它为降低Java企业级应用开发的难度而生。它可以减轻模块之间的管理，类与类之间的管理，帮助开发人员创建对象、管理对象之间的关系。 &emsp;&emsp;Spring的核心技术是IOC（控制反转）与AOP（面向切面编程），它能够实现模块之间、类与类之间的解耦合。 &emsp;&emsp;Spring全家桶：spring , springmvc , spring boot , spring cloud 2、如何学习框架 知道所学框架能够做什么，它的功能 掌握框架的语法，即要实现某一功能，需要哪些步骤 了解框架内部实现，原理是什么 3、使用Spring的步骤&emsp;&emsp;此处使用maven构建项目。 在pom.xml文件中加入依赖 创建并编写Spring主配置文件 实现ApplicationContext接口，通过getBean()方法获取指定对象 4、第一个Spring实例 FirstExp.java 1234//FirstExp接口public interface FirstExp { void doSome();} FirstExpImpl.java 123456789101112//实现FirstExp接口public class FirstExpImpl implements FirstExp { public SomeServiceImpl() { System.out.println(\"我是无参构造方法！！！\"); } @Override public void doSome() { System.out.println(\"我是第一个Spring实例\"); }} Spring主配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--使用bean标签创建对象，一个&lt;bean&gt;对应一个对象，id为对象名称，其值唯一--&gt; &lt;bean id=\"firstExp\" class=\"FirstExpImpl的全名\"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试方法MyTest.java 1234567891011public void Test(){ //使用spring容器创建对象 //1.指定spring配置文件的名称 String config = \"beans.xml\"; //2.创建spring容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(config); //3.从容器中获取指定对象 FirstExp exp = (FirstExp)ac.getBean(\"firstExp\"); //使用spring创建好的对象 exp.doSome();} 执行结果 Spring在内部通过构造方法创建对象，因此可以执行构造方法中的输出语句。","link":"/2021/04/23/%E5%88%9D%E8%AF%86spring/"},{"title":"spring整合mybatis","text":"1、整合思想&emsp;&emsp;使用Spring的ioc技术，把mybatis框架中的对象都交给spring创建和管理。Spring是容器，包含项目中的各种对象，例如：Service、Dao、工具类等对象。开发人员从spring中获取对象，就不用同时面对两个或多个框架，只需面对一个spring框架进行开发即可。 2、实现步骤 在pom文件中加入Spring依赖、Mybatis依赖、Spring和Mybayis整合依赖、druid连接池依赖等 编写数据库对应实体类、接口、mapper文件、service文件等 Spring主配置文件 Mybatis配置文件 3、整合实现示例 数据库字段 实体类Student 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student { private Integer id; private String name; private String email; private Integer age; public Student() {} public Student(Integer id, String name, String email, Integer age) { this.id = id; this.name = name; this.email = email; this.age = age; } public void setId(Integer id) { this.id = id; } public void setName(String name) { this.name = name; } public void setEmail(String email) { this.email = email; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", email='\" + email + '\\'' + \", age=\" + age + '}'; }} 接口StudentDao 1234public interface StudentDao { int insertStudent(Student student); //插入数据 List&lt;Student&gt; selectStudent(); //查询表中数据} Mapper文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.krain.dao.StudentDao\"&gt; &lt;!--在mybatis配置文件中已经通过typeAliases设置了别名， 因此resultType可直接使用student--&gt; &lt;select id=\"selectStudent\" resultType=\"student\"&gt; select * from student order by id desc &lt;/select&gt; &lt;insert id=\"insertStudent\"&gt; insert into student values (#{id}, #{name}, #{email}, #{age}) &lt;/insert&gt;&lt;/mapper&gt; StudentService 1234public interface StudentService { int addStudent(Student student); List&lt;Student&gt; selectStudent();} StudentServiceImpl Service层，实现StudentService接口。 12345678910111213141516171819202122232425public class StudentServiceImpl implements StudentService { private StudentDao studentDao = null; public StudentServiceImpl(StudentDao studentDao) { this.studentDao = studentDao; } public void setStudentDao(StudentDao studentDao) { this.studentDao = studentDao; } @Override public int addStudent(Student student) { int num = studentDao.insertStudent(student); return num; } @Override public List&lt;Student&gt; selectStudent() { List&lt;Student&gt; list = null; list = studentDao.selectStudent(); return list; }} Spring.xml 使用Druid数据库连接池 GitHub地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--使用druid数据库连接池--&gt; &lt;!--声明数据源对象--&gt; &lt;bean id=\"myDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;!--使用set注入为属性赋值--&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/DB_Name\"/&gt;&lt;!--setURL()--&gt; &lt;property name=\"username\" value=\"\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;property name=\"maxActive\" value=\"\"/&gt; &lt;!--同时存在的数据库连接池最大个数--&gt; &lt;/bean&gt; &lt;!-- 声明的是Mybatis中提供的SqlSessionFactoryBean类，在这个类的内部创建SqlSessionFactory对象 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--使用set注入，将数据库连接池赋给dataSource--&gt; &lt;property name=\"dataSource\" ref=\"myDataSource\"/&gt; &lt;!-- 告诉spring Mybatis主配置文件的位置， 使用configLocation的属性Resource类型读取Mybatis主配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:Mybatis.xml\"/&gt; &lt;/bean&gt; &lt;!--创建dao对象--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!--指定SqlSessionFactory对象的id--&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 指定dao类的包名，spring会扫描该包下所有的dao接口， 使每个接口都执行getMapper()，获取dao对象 将dao对象放入spring容器中，对象名默认为接口名首字母小写 --&gt; &lt;property name=\"basePackage\" value=\"cn.krain.dao\"/&gt; &lt;/bean&gt; &lt;!--创建service对象--&gt; &lt;bean id=\"studentService\" class=\"cn.krain.service.Impl.StudentServiceImpl\"&gt; &lt;!--使用set注入，为studentServiceImpl中的studentDao属性赋值--&gt; &lt;property name=\"studentDao\" ref=\"studentDao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Mybatis.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--为实体类设置别名--&gt; &lt;typeAliases&gt; &lt;!--name：实体类所在的包名 批量处理，自动起别名，名称为类名首字母小写--&gt; &lt;package name=\"cn.krain.domain\"/&gt; &lt;/typeAliases&gt; &lt;!--指定Sql映射文件（SQL Mapper）--&gt; &lt;mappers&gt; &lt;package name=\"cn.krain.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试类Test 12345678910111213141516171819202122232425262728293031323334353637public class MyTest { @Test public void Test01(){ //输出所有创建的对象 String config = \"applicationContext.xml\"; ApplicationContext ac = new ClassPathXmlApplicationContext(config); String names[] = ac.getBeanDefinitionNames(); for(String name:names){ System.out.println(\"创建的对象：\"+name); } } @Test public void TestServiceSelect(){ //查询所有数据 String config = \"applicationContext.xml\"; ApplicationContext ac = new ClassPathXmlApplicationContext(config); StudentService service = (StudentService) ac.getBean(\"studentService\"); List&lt;Student&gt; list = service.selectStudent(); for (Student st:list){ System.out.println(st); } } @Test public void TestServiceInsert(){ //插入数据 String config = \"applicationContext.xml\"; ApplicationContext ac = new ClassPathXmlApplicationContext(config); StudentService service = (StudentService) ac.getBean(\"studentService\"); Student student = new Student(); student.setId(7); student.setName(\"khan\"); student.setEmail(\"khan@qq.com\"); student.setAge(34); int num = service.addStudent(student); System.out.println(num); }} 执行结果","link":"/2021/04/23/spring%E6%95%B4%E5%90%88mybatis/"},{"title":"动态sql","text":"1、动态SQL&emsp;&emsp;概念：动态 SQL ，即 SQL 的内容是变化的，通过MyBatis提供的各种标签对条件作出判断以实现动态拼接 SQL 语句。可以根据条件获取到不同的 SQL 语句。常用的动态 SQL 标签有&lt;if&gt;、&lt;where&gt;、&lt;choose/&gt;、&lt;foreach&gt;等。MyBatis 的动态 SQL 语句，与 JSTL 中的语句非常相似。 &emsp;&emsp;动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行 查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行 排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题 2、动态SQL标签&emsp;&emsp;在 mapper 的动态 SQL 中若出现大于号（&gt;）、小于号（&lt;）、大于等于号（&gt;=），小于等于号（&lt;=）等 符号，最好将其转换为实体符号。否则，XML 可能会出现解析出错问题。 特别是对于小于号（&lt;），在 XML 中是绝不能出现的。否则解析 mapper 文件会出错。 比较符 对应实体符号 &gt; &amp;gt; &lt; &amp;lt; &gt;= &amp;gt;= &lt;= &amp;lt;= &lt;if&gt;标签 &emsp;&emsp;对于该标签的执行，当 test 的值为 true 时，会将其包含的 SQL 片断拼接到其所在的 SQL 语句中。 语法：&lt;if test=&quot;条件&quot;&gt; sql 语句的部分 &lt;/if&gt; 12345678&lt;!-- if标签：根据test中的条件判断是否成立，继而添加if中的内容--&gt;&lt;select id=\"selectStudentIf\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where &lt;if test=\" name!=null and name!='' \"&gt; name = #{name} &lt;/if&gt; &lt;if test=\" age&gt;0 \"&gt; or age &gt; #{age} &lt;/if&gt;&lt;/select&gt; &lt;where&gt;标签 &emsp;&emsp;&lt;if/&gt;标签的中存在一个比较麻烦的地方：需要在 where 后手工添加 1=1 的子句。因为，若 where 后 的所有&lt;if/&gt;条件均为 false，而 where 后若又没有 1=1 子句，则 SQL 中就会只剩下一个空的 where，SQL 出错。所以，在 where 后，需要添加永为真子句 1=1，以防止这种情况的发生。但当数据量很大时，会 严重影响查询效率。 &emsp;&emsp;使用&lt;where/&gt;标签，在有查询条件时，可以自动添加上 where 子句；没有查询条件时，不会添加 where 子句。需要注意的是，第一个&lt;if/&gt;标签中的 SQL 片断，可以不包含 and。不过，写上 and 也不错， 系统会将多出的 and 去掉。但其它&lt;if/&gt;中 SQL 片断的 and，必须要求写上。否则 SQL 语句将拼接出错 。 &emsp;&emsp;语法：&lt;where&gt; 其他动态 sql &lt;/where&gt; 1234567891011&lt;!-- where标签：根据if标签中的变量条件是否成立，添加where关键字 以及决定or、and的去留--&gt;&lt;select id=\"selectStudentWhere\" resultType=\"cn.krain.domain.Student\"&gt; select * from student &lt;where&gt; &lt;if test=\" name!=null and name!='' \"&gt; name = #{name} &lt;/if&gt; &lt;if test=\" age&gt;0 \"&gt; or age &gt; #{age} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;foreach&gt;标签 &emsp;&emsp;foreach标签：循环输出list或数组中的值，组合成一个完整的sql语句 属性： collection：数据类型（集合或数组） item：变量别名 open：循环开始时的字符 close：循环结束时的字符 separator：分隔符123456&lt;select id=\"selectForeachOne\" resultType=\"cn.krain.domain.Student\"&gt; select * from student where id in &lt;foreach collection=\"list\" item=\"myid\" open=\"(\" close=\")\" separator=\",\"&gt; #{myid} &lt;/foreach&gt;&lt;/select&gt; 3、组合代码片段&emsp;&emsp;&lt;sql/&gt;标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 &lt;include/&gt;子标签。 该&lt;sql/&gt;标签可以定义 SQL 语句中的任何部分，所以&lt;include/&gt;子标签可以放在动态 SQL 的任何位置。 123456789&lt;!--sql动态代码段--&gt;&lt;sql id=\"sqlOne\"&gt; select * from student&lt;/sql&gt;&lt;select id=\"selectSql\" resultType=\"cn.krain.domain.Student\"&gt; &lt;include refid=\"sqlOne\" /&gt; &lt;!--将id为SqlOne的SQL语句放到此处--&gt; where name like #{str}&lt;/select&gt;","link":"/2021/04/23/%E5%8A%A8%E6%80%81sql/"},{"title":"SSM项目中自定义监听器——实现数据字典","text":"Spring中自定义监听器——实现数据字典一、JavaWeb中监听器类型JavaWeb中共有三种监听器，分别是ServletContextListener，HttpSessionListener，ServletRequestListener；他们分别对应的作用域是Application、Session、Request，实现各自类型的接口即可实现监听器的创建。 二、使用方式（ServletContextLisenter为例）1234567891011121314151617181920package cn.krain.crm.web.listener;/** * @author CC * @data 2020/8/1 - 22:28 */public class SysInitLisenter implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"-------------------start initServlet------------------\"); //... System.out.println(\"-------------------end initServlet-----------------\"); } @Override public void contextDestroyed(ServletContextEvent sce) { }} 可在contextInitialized和contextDestroyed方法中根据所要实现功能进行代码编写。 web.xml 123&lt;listener&gt; &lt;listener-class&gt;监听器的类路径&lt;/listener-class&gt;&lt;/listener&gt; 三、注意事项由于在SSM项目中使用Spring注解的方式创建对象，并且监听器在web.xml中最先被执行，因此在监听器方法执行时，无法进行bean的自动注入；可使用如下方法： 12345ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(sce.getServletContext());//获取beantypeDao = context.getBean(DicTypeDao.class);valueDao = context.getBean(DicValueDao.class); 不使用getBean方法为所使用的的对象赋值时会报空指针异常，因为没有创建，对象无法正常使用，从而服务器无法正常启动（这个bug我改了一天，吐了）；总结一下，希望能够帮到大家。 四、实现数据字典通过Application监听器可以实现数据字典。 数据字典概念：即对于在数据库中不经常改变的数据，可以放入到application域中，直接使用，不用再从数据库中获取。 服务器启动，执行监听器方法，通过使用对应数据的Dao层对象获取数据并放入到application域中，在页面上通过JSTL配合EL表达式直接使用。 适合场景：比如网站中下拉列表中的数据，一般不会改变，加载页面时又需要用到，使用数据字典非常方便。","link":"/2021/04/23/SSM%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E5%90%AC%E5%99%A8%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/"},{"title":"mybatis-入门","text":"前言：作为一名在未来要从事计算机工作的在校学生，在学习任何一种知识或技术之前，我认为需要先明白三个问题： 为什么要学习它 它有什么作用 学完后对我有什么提升 弄清楚以上问题后，我认为学习的效果会大大提升。 1、Mybatis简介&emsp;&emsp;按照mybatis官方文档的定义，MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 2、为什么要使用Mybatis&emsp;&emsp;在使用传统的JDBC时有没有感觉到一个问题——在对数据库进行增删改查的过程中，对数据库的任何一个操作我们都需要创建一个单独的方法，频繁的进行相关对象的创建和关闭；并且在方法的内部，众多代码都是重复的，只有SQL语句和执行的方法略有不同；而使用Mybatis就可以解决这种问题。 3、Mybatis提供的功能 提供了创建Connection、PreparedStatement、Statement、ResultSet等对象的功能，不需要开发人员创建 提供了执行SQL语句的功能 提供了遍历SQL结果，将结果集转化为Java对象、List集合的功能 提供了关闭资源的功能 &emsp;&emsp;通过Mybatis提供的功能，开发人员只需要集中精力写SQL语句，根据相关类的调用，让Mybatis对SQL语句进行处理，我们可以得到含有数据信息的List集合或Java对象。 4、使用前准备工作 在maven项目中的pom.xml文件中加入Mybatis依赖 123456&lt;!--Mybatis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt; Mybatis主配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--控制Mybatis--&gt; &lt;settings&gt; &lt;!--开启输出日志功能--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--指定所使用的数据库--&gt; &lt;environments default=\"dbTest\"&gt; &lt;!--一个environment代表一个数据库--&gt; &lt;environment id=\"dbTest\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--POOLED为连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--指定数据库驱动--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;!--指定URL--&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/user_test\"/&gt; &lt;!--数据库用户名--&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;!--密码--&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定Sql映射文件（SQL Mapper）--&gt; &lt;mappers&gt; &lt;mapper resource=\"映射文件的相对路径\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; SQL映射文件 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!--约束文件，检查该文件格式是否符合Mybatis语法--&gt;&lt;!--namespace指定接口--&gt;&lt;mapper namespace=\"接口文件全名\"&gt; &lt;select id=\"接口中方法名\" resultType=\"返回值的数据类型\"&gt; &lt;!-- 查询SQL语句 --&gt; &lt;/select&gt; &lt;insert id=\"接口中方法名\"&gt; &lt;!-- 插入SQL语句 --&gt; &lt;/insert&gt; &lt;update id=\"接口中方法名\"&gt; &lt;!-- 更新SQL语句 --&gt; &lt;/update&gt; &lt;delete id=\"接口中方法名\"&gt; &lt;!-- 删除SQL语句 --&gt; &lt;/delete&gt;&lt;/mapper&gt; &emsp;&emsp;SQL映射文件中的接口及接口中的方法会在后续的文章中进行解释，该分栏持续更新中…","link":"/2021/04/23/mybatis-%E5%85%A5%E9%97%A8/"},{"title":"mybatis-动态代理实现增删改查","text":"&emsp;&emsp;在上一篇文章中，我们使用静态代理的方式，通过一个类来实现DAO接口从而实现增删改查；在这篇文章中，将使用动态代理的方式进行功能的实现，其原理是Java的反射机制。话不多说，先上代码为敬。 TestMybatis文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package cn.krain;import cn.krain.dao.StudentDao;import cn.krain.domain.Student;import cn.krain.utils.MybatisUtil;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class TestMybatis { //查询功能 @Test public void testSelectStudents(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); List&lt;Student&gt; students = dao.selectStudents(); sqlSession.close(); for (Student stu:students) { System.out.println(stu); } } //插入功能 @Test public void testInsertStudent(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); Student student = new Student(); student.setId(7); student.setName(\"花花2\"); student.setEmail(\"8654@qq.com\"); student.setAge(21); int n = dao.insertStudent(student); sqlSession.commit(); sqlSession.close(); System.out.println(n); } //更新功能 @Test public void testUpdateStudent(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); Student student = new Student(); student.setId(7); student.setAge(10); int n = dao.updateStudent(student); sqlSession.commit(); sqlSession.close(); System.out.println(n); } //删除功能 @Test public void testDeleteStudent(){ SqlSession sqlSession = MybatisUtil.getSqlSession(); StudentDao dao = sqlSession.getMapper(StudentDao.class); Student student = new Student(); student.setId(7); int n = dao.deleteStudent(student); sqlSession.commit(); sqlSession.close(); System.out.println(n); }} 在上篇文章 使用静态代理实现 的基础上，我只需要去掉实现接口的类，同时修改TestMybatis类；在TestMybatis类中，当每个方法获取DAO对象时，使用SqlSession对象中的getMapper(dao.class)方法即可。","link":"/2021/04/23/mybatis-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"title":"IOC","text":"一、Spring核心技术——IOC&emsp;&emsp;IOC是Inversion of Control的缩写，即控制反转；是一种思想、理论、概念。IOC把对象的创建、管理、属性的赋值，都交给代码之外的容器实现，通过外部资源完成。使用ICO的目的就是在减少对代码改动的情况下，实现不同的功能，实现解耦合。 控制：创建对象，对象的属性赋值，对象之间的关系管理。 反转：把原来的开发人员管理，创建对象的权限转移给代码之外的容器实现。由容器代替开发人员管理对象。创建对象，给属性赋值。 正转：由开发人员在代码中，使用new构造方法创建对象，开发人员主动管理对象。 DI（Dependence Injection）：依赖注入，是IOC的的技术实现，只需要在程序中提供要使用的对象名称就可以；至于对象如何在容器中创建，赋值，查找都由容器内部实现，其底层原理是反射机制。 二、使用IOC创建对象 Java中创建对象的方式 构造方法（new） 反射 序列化 克隆 动态代理 IOC（容器创建对象） 使用xml配置文件创建对象 在spring主配置文件中使用&lt;bean&gt;标签为属性赋值。 使用IOC可以创建自定义类的对象，也可以创建非自定义类的对象。 同一个类可以使用多个&lt;bean&gt;标签创建不同名称的对象。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 一个bean对应一个对象，id为创建的对象的名称，因此值唯一 --&gt; &lt;bean id=\"object1\" class=\"类的全名\"&gt;&lt;/bean&gt; &lt;bean id=\"object2\" class=\"类的全名\"&gt;&lt;/bean&gt; &lt;!--spring可以创建已存在的非自定义的类，例如创建Java中的日期类对象--&gt; &lt;bean id=\"mydate\" class=\"java.util.Date\"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用注解创建对象 @Component()：可以对任意类创建对象 语法：@Component(value=”对象名称”) 或 @Component(“对象名称”) 或 @Component() 使用方法：首先在spring主配置文件中加入组件扫描器(component-scan)，之后直接在类名上方加入该注解即可。 123456@Component(\"myStudent\")public class Student {}//未指定对象名称时，spring默认以类名首字母小写作为对象名@Component()public class Student {} @Repository()：用在持久层类的上面，创建dao层的对象。 @Service()：用在业务层上面，创建service层的对象。 @Controller()：用在控制层上面，创建控制层的对象。 &emsp;&emsp;类和注解编写完成后需要在spring主配置文件中加入组件扫描器： 1&lt;context:component-scan base-package=\"类文件所在的包名\" /&gt; 三、使用IOC为属性赋值&emsp;&emsp;Spring规定Java中的基本类型和String类型的数据均为简单类型，其他的均为引用类型。 使用xml配置文件为属性赋值 set注入 &emsp;&emsp;前提：set注入，顾名思义是使用类中的setXXX()方法进行属性的赋值，赋值时Spring会自动调用对应类中的对应setXXX()方法，因此如果使用set注入方式为属性赋值，类中就必须有相应的setXXX()方法。 &emsp;&emsp;该方式是在&lt;bean&gt;标签中使用&lt;property&gt;标签，name的值为变量名称，value和ref为所要赋的目标值。 1234567&lt;bean id=\"对象名\" class=\"类全名\"&gt; &lt;!--简单类型：使用属性value--&gt; &lt;property name=\"name\" value=\"krain\"/&gt; &lt;property name=\"age\" value=\"23\"/&gt; &lt;!--引用类型：使用属性ref--&gt; &lt;property name=\"school\" ref=\"myschool\"/&gt;&lt;/bean&gt; 含参构造注入 &emsp;&emsp;前提：使用对应类的含参构造方法为属性赋值。Spring在创建对象时调用含参构造方法同时为属性赋值，因此舒勇此方法是必须设置含参构造方法。 使用含参构造注入为属性赋值有以下几种方式： 1）使用标签的name属性 123456&lt;!--使用name属性--&gt;&lt;bean id=\"student\" class=\"cn.krain.ba03.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt; &lt;constructor-arg name=\"age\" value=\"12\"/&gt; &lt;constructor-arg name=\"school\" ref=\"myschool\"/&gt;&lt;/bean&gt; 2）使用标签的index属性 &emsp;&emsp;&lt;constructor-arg&gt;标签中index属性的值为构造方法参数的顺序，从0开始。 123456&lt;!--使用name属性--&gt;&lt;bean id=\"student2\" class=\"cn.krain.ba03.Student\"&gt; &lt;constructor-arg index=\"0\" value=\"李斯\"/&gt; &lt;constructor-arg index=\"1\" value=\"21\"/&gt; &lt;constructor-arg index=\"2\" ref=\"myschool\"/&gt;&lt;/bean&gt; 3）省略index属性 &emsp;&emsp;直接按构造方法的参数顺序赋值。 123456&lt;!--使用name属性--&gt;&lt;bean id=\"student3\" class=\"cn.krain.ba03.Student\"&gt; &lt;constructor-arg value=\"王五\"/&gt; &lt;constructor-arg value=\"34\"/&gt; &lt;constructor-arg ref=\"myschool\"/&gt;&lt;/bean&gt; 自动注入 &emsp;&emsp;Spring可以根据byName或byType规则自动给引用类型赋值。 1）byName（按姓名注入） 要求：java类中引用类型变量的名称和bean标签id的名称一样，且数据类型是一致的 语法：`&lt;bean name=&quot;xxx&quot; class=&quot;yyy&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;` 2）byType（按类型注入） java引用数据类型和spring容器中（配置文件）`&lt;bean&gt;`中的class的值是同源（同一类）关系 以下三种情况可用byType： 1)java类中引用类型的数据类型和bean的class的值是一类 2)java类中引用类型的数据类型和bean的class的值是父子类关系 3)java类中引用类型的数据类型和bean的class的值是接口与实现类的关系 注意事项：使用byType时，在xml配置文件中声明的bean只能有一个符合条件的，否则会报错 使用注解为属性赋值 @Value() &emsp;&emsp;为简单赋值属性，直接在类中对应属性上方加入注解即可。 1234567@Component(\"myStudent\")public class Student { @Value(\"张飞\") private String name; @Value(\"233\") private Integer age;} @Autowired() &emsp;&emsp;为引用类型属性赋值，有byName和byType两种方式，默认使用byType方式。 123456789101112131415161718192021222324@Component(\"myStudent\")public class Student { @Value(\"张飞\") private String name; @Value(\"233\") private Integer age; /* * 为引用数据类型赋值：自动注入 byType byName * @Autowired：默认使用的是byType自动注入 * * 使用byName时： * 1.在属性上面加入@Autowired * 2.在属性上面加入@Qualifier(\"属性名，即bean的id\") * */ //使用byName @Autowired @Qualifier(\"mySchool\") //引用类型数据的名称 private School school; //使用byType，根据属性的类型自动赋值 @Autowired private School school;} @Resource() &emsp;&emsp;JDK中的注解，使用自动注入为引用类型属性赋值，支持byName、byType，默认是byName。 123456789101112131415161718192021222324@Component(\"myStudent\")public class Student { @Value(\"张飞\") private String name; @Value(\"244\") private Integer age; /* * 使用@Resource：该注解来自jdk，spring框架提供了对这个注解的功能支持 * 同样是自动注入原理，支持byName byType，默认是byName * Resource会先使用byName注入，如果byName赋值失败，会自动使用byType */ //默认为byName @Resource(name = \"mySchool\") private School school; //byType @Resource() private School school; ...} &emsp;&emsp;类和注解编写完成后需要在spring主配置文件中加入组件扫描器： 1&lt;context:component-scan base-package=\"类文件所在的包名\" /&gt;","link":"/2021/04/23/IOC/"},{"title":"SpringMVC处理Web请求","text":"一、注解 @Controller 作用：用于创建控制器对象。该对象能够处理Web请求。 位置：该注解位于类名上方。 12@Controllerpublic class MyController {} @RequestMapping 作用：请求映射，用于将指定请求绑定到指定方法上，该方法用于处理对应请求。 属性：value：设置请求的url，值唯一；method：设置提交请求的方式（取值为get/post） 位置：该注解位于方法名上方。 12@RequestMapping(value = \"/some.do\", method = RequestMethod.GET)public ModelAndView doSome(){} 二、视图解析器视图解析器用于简化指定返回视图的操作，直接使用文件名即可——modelAndView.setViewName(&quot;文件名称&quot;) prefix：文件路径前缀 suffix：文件后缀名，例如：”.jsp” 1234567&lt;!--声明springmvc框架中的视图解析器，帮助开发人员设置视图文件路径--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--前缀：视图文件路径--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt; &lt;!--后缀：视图文件扩展名--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 转发路径：”/WEB-INF/view/“ + “文件名称” + “.jsp” 三、接收参数 直接在处理器方法中获取 在处理器方法的参数中加入HttpServletRequest、HttpServletResponse、HttpSession三个参数。 1234567@RequestMapping(value = \"/return-view.do\")public String returnView(HttpServletRequest request, HttpServletResponse response, HttpSession session){ //可以手工在request域中加入参数 request.setAttribute(\"name\",name); request.setAttribute(\"age\",age); return \"show\";} 接收简单类型参数 表单中代码： 123456&lt;h1&gt;请输入姓名和年龄：&lt;/h1&gt;&lt;br&gt;&lt;form action=\"receiveproperty.do\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"age\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt; 参数名相同时：在处理器方法中加入与表单参数名称和个数相同的参数。 12345678@RequestMapping(value = \"/receiveproperty.do\")public ModelAndView doSome(String name, Integer age){ ModelAndView mv = new ModelAndView(); mv.addObject(\"myName\",name); mv.addObject(\"myAge\",age); mv.setViewName(\"show\"); return mv;} 与表单参数名不同时：在处理器方法中加入相同个数的参数；在对应参数前使用@RequestParam(value = “与表单参数名相同的参数名”)，即可将参数赋给对应变量。 123456&lt;h1&gt;表单中参数名与控制器方法中的参数名不一致时&lt;/h1&gt;&lt;br&gt;&lt;form action=\"receiveparam.do\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"rname\"&gt;&lt;br&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"rage\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt; 12345678910@RequestMapping(value = \"/receiveparam.do\")public ModelAndView receiveparam(@RequestParam(value = \"rname\") String name, @RequestParam(value = \"rage\") Integer age){ System.out.println(\"name:\"+name+\" age:\"+age); ModelAndView mv = new ModelAndView(); mv.addObject(\"myName\",name); mv.addObject(\"myAge\",age); mv.setViewName(\"show\"); return mv;} 接收引用类型参数 123456&lt;h1&gt;使用java对象接收参数&lt;/h1&gt;&lt;br&gt;&lt;form action=\"receiveObj.do\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt;&lt;br&gt; 年龄：&lt;input type=\"text\" name=\"age\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt; Student对象： 12345678910111213141516171819202122public class Student { private String name; private Integer age; public Student() { System.out.println(\"执行了Student无参数构造方法\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 在处理器方法中加入Student变量，表单中的参数会通过容器调用对应setXXX()方法，为对应属性赋值。 注意：表单中的参数名必须和对象中的属性名一致。 123456789@RequestMapping(value = \"/receiveObj.do\")public ModelAndView receiveObj(Student myStudent){ ModelAndView mv = new ModelAndView(); mv.addObject(\"myName\",myStudent.getName()); mv.addObject(\"myAge\",myStudent.getAge()); mv.addObject(\"myStudent\",myStudent); mv.setViewName(\"show\"); return mv;} 接收Map、List、数组等（与应用类型赋值相同） 三、设置参数编码在表单提交时，通过post方式会产生中文乱码，使用过滤器解决——CharacterEncodingFilter，解决POST提交方式中文乱码问题。 在web.xml文件中注册过滤器如下： 12345678910111213141516171819202122232425262728&lt;!--注册过虑器，解决post请求乱码问题--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--设置项目中使用的字符编码--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--强制该对象（HttpServletRequest）使用encoding编码的值--&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--强制该对象（HttpServletResponse）使用encoding编码的值--&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!-- \"/*\"表示所有的请求都要先通过过滤器处理 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 四、接收返回值 ModelAndView类型 addObject()方法用于添加数据，底层使用reques.setAttribute()方法实现； setViewName()方法用于转发视图，底层使用forward或redirect实现。 12345678@RequestMapping(value = \"/receiveproperty.do\")public ModelAndView doSome(String name, Integer age){ ModelAndView mv = new ModelAndView(); mv.addObject(\"myName\",name); mv.addObject(\"myAge\",age); mv.setViewName(\"show\"); return mv;} void类型 void类型通常配合ajax使用。 123456789101112131415161718192021222324252627282930&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;发送请求&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jQuery-3.5.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function () { $(\"#bt\").click(function () { $.ajax({ url:\"returnVoid-ajax.do\", data:{ name:\"zhangsan\", age:20 }, type:\"post\", dataType:\"text\", success(resp){ //resp是从服务器返回的json格式的字符串，{name:\"zhangsan\",age:\"20\"} //jQuery会把字符转化为json对象，赋值给resp alert(resp.name+\" \"+resp.age) } }) }) }) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"bt\"&gt;发起Ajax请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021@RequestMapping(value = \"/returnVoid-ajax.do\")public void returnVoid(HttpServletResponse response,String name, Integer age) throws IOException { Student student = new Student(); student.setName(name); student.setAge(age); //转化为json格式 String json = \"\"; if (student!=null){ ObjectMapper om = new ObjectMapper(); json = om.writeValueAsString(student); System.out.println(\"student转换为json：\"+json); } //输出数据，响应json请求 response.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = response.getWriter(); out.println(json); out.flush(); out.close();} String类型 表示数据： 返回值是String类型，表示数据，此时含有@ResponseBody注解 默认编码为：text/plain;charset=ISO-8859-1，会出现中文乱码，使用produces更改编码 12345@RequestMapping(value = \"/returnStringData.do\",produces = \"text/plain;charset=UTF-8\")@ResponseBodypublic String returnStringData(String name, Integer age){ return \"Hello SpringMVC ========奥利奥\";} ​ 表示视图： ​ 理器方法返回String（表示视图，此时没有@ResponseBody注解）——表示逻辑视图名称，需要配置视图解析器 ​ 当返回值是视图完整路径时需要取消视图解析器，因为视图解析器会进行字符拼接。 12345678@RequestMapping(value = \"/return-view.do\")public String returnView(HttpServletRequest request, String name, Integer age){ System.out.println(\"name:\"+name+\" age:\"+age); //可以手工在request域中加入参数 request.setAttribute(\"name\",name); request.setAttribute(\"age\",age); return \"show\";} Object类型 使用Ajax时主要使用json数据类型&lt;mvc:annotation-driven /&gt;：注解驱动，能够将java对象转化为json、xml、二进制等数据类型@ResponseBody注解：放到处理器方法上面处理器将对象转化为json后，在内部通过HttpServletResponse输出数据，相应Ajax请求 12345678@RequestMapping(value = \"/returnStudentObject.do\")@ResponseBodypublic Student returnStudentObject(String name, Integer age){ Student student = new Student(); student.setName(\"lisi\"); student.setAge(23); return student;}","link":"/2021/04/23/SpringMVC%E5%A4%84%E7%90%86Web%E8%AF%B7%E6%B1%82/"},{"title":"mybatis-实现增删改查","text":"1、mybatis中的核心对象 Resources对象 &emsp;&emsp;Mybatis中的一个类，用于读取mybatis的主配置文件。 1InputStream in = Resources.getResourceAsStream(\"mybatis.xml\"); SqlSessionFactoryBuilder对象 &emsp;&emsp;用于创建SqlSessionFactory对象。 12SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(in); SqlSessionFactory对象 &emsp;&emsp;是一个接口，用于获取Sqlession对象，由于程序创建一个对象耗时比较长，使用资源比较多，所以在整个项目中，有一个就够用了。 1234SqlSession sqlSession = factory.openSession();//openSession()方法括号中参数值为true、false//默认为false表示获取非自动提交事务的SqlSession//true表示获取非自动提交事务的SqlSession SqlSession对象 &emsp;&emsp;该对象是一个接口，定义了操作数据的方法 例如 selectOne() , selectList(), insert(), update(), delete(), commit(), rollback() &emsp;&emsp;在执行完SQL语句之后，需要关闭，sqlSession.close(); 2、使用mybatis实现增删改查 数据库表 接口文件 123456789101112131415package cn.krain.dao;import cn.krain.domain.Student;import java.util.List;public interface StudentDao { List&lt;Student&gt; selectStudents(); int insertStudent(Student student); int updateStudent(Student student); int deleteStudent(Student student);} SQL映射文件 id值为接口文件中的方法名，用来映射对应方法&emsp;resultType为查询结果的类型 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.krain.dao.StudentDao\"&gt; &lt;select id=\"selectStudents\" resultType=\"cn.krain.domain.Student\"&gt; select * from student order by id &lt;/select&gt; &lt;insert id=\"insertStudent\"&gt; insert into student values (#{id},#{name},#{email},#{age}) &lt;/insert&gt; &lt;update id=\"updateStudent\"&gt; update student set age=#{age} where id = #{id} &lt;/update&gt; &lt;delete id=\"deleteStudent\"&gt; delete from student where id = #{id} &lt;/delete&gt;&lt;/mapper&gt; Mybatis主配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;!--指定所使用的数据库--&gt; &lt;environments default=\"dbTest\"&gt; &lt;!--一个environment代表一个数据库--&gt; &lt;environment id=\"dbTest\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/user_test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定Sql映射文件（SQL Mapper）--&gt; &lt;mappers&gt; &lt;mapper resource=\"cn\\krain\\dao\\StudentDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 实现接口的类 sqlSqssion通过sqlId，在映射文件中查找对应的sql语句并执行。 sqlId由接口全名与方法名的拼接而组成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.krain.dao.impl;import cn.krain.dao.StudentDao;import cn.krain.domain.Student;import cn.krain.utils.MybatisUtil;import org.apache.ibatis.session.SqlSession;import java.util.List;public class StudentDaoImpl implements StudentDao { @Override public List&lt;Student&gt; selectStudents() { SqlSession sqlSession = MybatisUtil.getSqlSession(); //sql String sqlId = \"cn.krain.dao.StudentDao\"+\".\"+\"selectStudents\"; List&lt;Student&gt; students = sqlSession.selectList(sqlId); sqlSession.close(); return students; } @Override public int insertStudent(Student student) { SqlSession sqlSession = MybatisUtil.getSqlSession(); String sqlId = \"cn.krain.dao.StudentDao.insertStudent\"; int num = sqlSession.insert(sqlId,student); sqlSession.commit(); sqlSession.close(); return num; } @Override public int updateStudent(Student student) { SqlSession sqlSession = MybatisUtil.getSqlSession(); String sqlId = \"cn.krain.dao.StudentDao.updateStudent\"; int num = sqlSession.insert(sqlId,student); sqlSession.commit(); sqlSession.close(); return num; } @Override public int deleteStudent(Student student) { SqlSession sqlSession = MybatisUtil.getSqlSession(); String sqlId = \"cn.krain.dao.StudentDao.deleteStudent\"; int num = sqlSession.insert(sqlId,student); sqlSession.commit(); sqlSession.close(); return num; }} Student数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.krain.domain;public class Student { private Integer id; private String name; private String email; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", email='\" + email + '\\'' + \", age=\" + age + '}'; }} MybatisUtil工具类 该类用于封装获取sqlSession的代码。 12345678910111213141516171819202122232425262728293031323334package cn.krain.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtil { private static SqlSessionFactory factory = null; static { String config = \"mybatis.xml\"; try { //读取主配置文件 InputStream in = Resources.getResourceAsStream(config); //为factory赋值 factory = new SqlSessionFactoryBuilder().build(in); } catch (IOException e) { e.printStackTrace(); } } public static SqlSession getSqlSession(){ SqlSession sqlSession = null; if (factory!=null){ sqlSession = factory.openSession(); //非自动提交事务 } return sqlSession; }} TestMybatis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.krain;import cn.krain.dao.StudentDao;import cn.krain.dao.impl.StudentDaoImpl;import cn.krain.domain.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMybatis { @Test public void testSelectStudents(){ StudentDao studentDao = new StudentDaoImpl(); List&lt;Student&gt; studentList = studentDao.selectStudents(); for (Student stu:studentList ) { System.out.println(stu); } } @Test public void testInsertStudent(){ StudentDao dao = new StudentDaoImpl(); Student student = new Student(); student.setId(6); student.setName(\"花花\"); student.setEmail(\"8654@qq.com\"); student.setAge(21); int n = dao.insertStudent(student); System.out.println(n); } @Test public void testUpdateStudent(){ StudentDao dao = new StudentDaoImpl(); Student student = new Student(); student.setId(4); student.setAge(10); int n = dao.updateStudent(student); System.out.println(n); } @Test public void testDeleteStudent(){ StudentDao dao = new StudentDaoImpl(); Student student = new Student(); student.setId(2); int n = dao.deleteStudent(student); System.out.println(n); }}","link":"/2021/04/23/mybatis-%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"},{"title":"aop","text":"一、AOP简介&emsp;&emsp;AOP是Aspect Orient Programming的缩写，即面向切面编程。基于动态代理的，可以使用jdk和cglib两种代理方式。 Aspect: 切面，给你的目标类增加的功能，就是切面。像上面用的日志，事务都是切面。切面的特点：一般都是非业务方法，独立使用的。 Orient：面向，对着。 Programming：编程 &emsp;&emsp;AOP就是动态代理的规范化，把动态代理的实现步骤，方式都定义好了，让开发人员用一种统一的方式，使用动态代理。 作用： 在目标类不修改的情况下增加功能 减少代码的重复 使开发人员专注业务功能的实现 解耦合：业务功能和日志、事务等非业务功能的耦合 二、动态代理的实现方式 jdk动态代理 &emsp;&emsp;使用jdk中的Proxy，Method，InvocaitonHanderl创建代理对象。jdk动态代理要求目标类必须实现接口 cglib动态代理 &emsp;&emsp;第三方的工具库，创建代理对象，原理是继承。 通过继承目标类，创建子类。子类就是代理对象。要求目标类不能是final的，方法也不能是final的。 三、AOP中名词概念 aspect（切面）：表示给业务方法增加的功能，一般为体制输出、事务、权限检查等 JoinPoint：连接点，连接业务方法和切面的位置，就某类中的业务方法 pointcut（切入点）：是一个或多个JoinPoint的集合，表示切面功能执行的位置 目标对象：给哪个类的方法增加功能，这个类就是目标对象 advice（通知）：也叫增强。表示切面执行的时间，在方法前或后 四、何时使用AOP 某项目功能类不完善，需要增加功能，但是没有源代码 给项目的多个类需要增加相同功能 为业务功能增加事务、日志输出 …… 五、AOP的实现1、Spring&emsp;&emsp;Spring在内部实现了aop规范，能做aop的工作。spring主要在事务处理时使用aop，在项目开发中很少使用spring的aop实现，因为spring的aop比较笨重。 2、使用Aspectj框架实现AOP&emsp;&emsp;一个开源的专门做aop的框架。spring框架中集成了aspectj框架，通过spring就能使用aspectj的功能。 aspectJ框架实现aop有两种方式： 1、使用xml的配置文件 ： 配置全局事务2、使用注解，项目中要做aop功能，一般都使用注解 使用相应注解确定切面执行的时间 使用切面表达式确定切面执行的位置 &emsp;&emsp;切面位置的切入点表达式：execution(修饰符 返回值 包名.类名.方法名(方法参数) 异常)。用来指定切面执行的位置。 aspectj中常用注解如下： @Aspect：声明该类是切面类 12345678/** @Aspect：是Aspectj框架中的注解* 作用：声明该类是切面类* 切面类：为目标类增加功能的类，包含切面的功能代码* 位置：在类的上面* */@Aspectpublic class MyAspect {} @Before：前置通知，在目标方法之前执行切面的功能 123456789101112131415161718192021@Aspectpublic class MyAspect { /* * 定义方法，是实现切面功能的方法 * 方法定义要求： * 1、方法时公共的 * 2、方法名自定义 * 3、方法没有返回值 * 4、可以有参数，也可以无参数 * 如果有参数，参数不是自定义的 * @Before：前置通知注解 * 属性：value，是切入点表达式，表明切面的功能执行的位置 * 位置：在方法的上面 * 特点： * 1、在目标方法前执行 * 2、不会改变和影响目标方法的执行 * */ @Before(value = \"execution(public void cn.krain.ba01.SomeServiceImpl.doSome(String,Integer))\") public void myBefore(){ System.out.println(\"前置通知，切面功能，在目标方法执行前输出执行的时间：\"+new Date()); } @AfterReturning：后置通知，在目标方法之后执行切面的功能，能获取返回值 12345678910111213141516171819202122232425262728@Aspectpublic class MyAspect { /* * @AfterReturning定义方法，是实现切面功能的方法 * 方法定义要求： * 1、方法时公共的 * 2、方法名自定义 * 3、方法没有返回值 * 4、方法有参数 * @AfterReturning：后置通知 * 属性：1、value：切入点表达式 * 2、returning：自定义变量，目标方法的返回值 * 自定义变量名称和通知方法的形参名一致 * 位置：在方法定义的上面 * 特点： * 1、在目标方法之后执行 * 2、能获取目标方法的返回值 * 3、可修改这个返回值 * */ @AfterReturning(value = \"execution(* cn.krain.ba02.SomeServiceImpl.doOther(..))\", returning=\"res\") public void myAfterReturning(Object res){ System.out.println(\"后置通知，切面功能，在目标方法执行前输出执行的时间：\"+res); if (res!=null){ res = \"Hello\"; } }} @Around：环绕通知，能在目标方法前后增强功能，能够控制目标方法的执行，修改返回值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Aspectpublic class MyAspect { /* * 环绕通知的定义格式 * 方法定义要求： * 1、方法时公共的 * 2、方法名自定义 * 3、必须有返回值 * 4、方法有固定的参数：proceedingJoinPoint * @Around：环绕通知 * 属性：value 切入点表达式 * 位置：在方法的定义上面 * 特点： * 1、是功能最强的通知 * 2、能够在目标方法前后增强功能 * 3、控制目标方法是否被执行 * 4、修改原来目标方法的执行结果，影响最后的调用结果 * */ @Around(value = \"execution(* *..SomeServiceImpl.doFirst(..))\" ) public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable { //获取第一个参数的值 String name = null; Object args [] = joinPoint.getArgs(); if (args!=null &amp;&amp; args.length&gt;=1){ Object arg = args[0]; name = (String) arg; } Object result = null; //实现环绕通知 System.out.println(\"环绕通知，在目标方法之前，输出时间：\"+new Date()); //1、目标方法调用 //控制目标方法的执行 if (name.equals(\"张三\")){ result = joinPoint.proceed(); //等同于执行目标方法 } System.out.println(\"环绕通知，在目标方法之后，提交事务\"); //修改目标函数返回结果 if (result!=null){ result = \"Hello Aop\"; } return result; }} @AfterThrowing：异常通知，在目标方法抛出异常后执行 12345678910111213141516171819202122232425262728293031@Aspectpublic class MyAspect { /* 异常通知的定义格式 * 方法定义要求： * 1、方法时公共的 * 2、方法名自定义 * 3、方法没有返回值 * 4、固定参数Exception，如果还有参数则是：JoinPoint * 5、throwing的值要与Exception的参数名相同 * @AfterThrowing：异常通知 * 属性：1、value 切入点表达式 * 2、throwing 自定义变量，表示目标方法抛出的异常对象 * 如果有异常，通过邮件、短信通知 * 特点： * 1、在目标方法出现异常时执行 * 2、监控目标方法是否存在异常 * * 执行过程： * try{ * SomeServiceImpl.doSecond(); * }catch(Exception e){ * myAfterThrowing(e); * } * */ @AfterThrowing(value = \"execution(* *..SomeServiceImpl.doSecond())\", throwing = \"ex\") public void myAfterThrowing(Exception ex){ System.out.println(\"异常通知，方法执行异常，执行：\"+ex.getMessage()); //发送短信 }} @After：最终通知，总是会执行 123456789101112131415161718192021222324252627282930313233@Aspectpublic class MyAspect { /* 最终通知的定义格式 * 方法定义要求： * 1、方法时公共的 * 2、方法名自定义 * 3、方法没有返回值 * 4、没有参数，如果有参数则是：JoinPoint * */ /* * @After 最终通知 * 属性：value 切入表达式 * 位置：在方法的上面 * * 特点： * 1、总是会执行 * 2、在目标方法之后执行 * * 执行过程: * try{ * //目标方法 * }catch(){ * * }finally{ * myAfter(); * } * */ @After(value = \"execution(* *..SomeServiceImpl.doThird(..))\") public void myAfter(){ System.out.println(\"执行最终通知，总是会被执行的代码\"); }} @Pointcut：定义和管理切入点的辅助注解 12345678910111213141516171819202122@Aspectpublic class MyAspect { @After(value = \"myPT()\") public void myAfter(){ System.out.println(\"执行最终通知，总是会被执行的代码\"); } @Before(value = \"myPT()\") public void myBefore(){ System.out.println(\"执行前置通知\"); } /* * @Pointcut：定义和管理切入点表达式，如果项目中的切入点表达式是重复的，可使用Pointcut * 属性：value 切入点表达式 * 位置：在自定义方法上面 * 为切入点表达式定义别名，使用\"方法名称()\"代替切入点表达式 * */ @Pointcut(value = \"execution(* *..SomeServiceImpl.doThird(..))\") private void myPT(){ //无功能代码 }} 编写spring主配置文件 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--把对象交给spring，有spring统一创建和管理--&gt; &lt;!--创建SomeService目标对象--&gt; &lt;bean name=\"someService\" class=\"cn.krain.ba.SomeServiceImpl\" /&gt; &lt;!--创建aspect切面对象--&gt; &lt;bean name=\"myAspect\" class=\"cn.krain.ba.MyAspect\" /&gt; &lt;!-- 声明自动代理生成器：使用aspectj的内部功能，创建目标对象的代理对象。 创建代理对象是在内存中实现的，修改目标对象在内存中的结构，创建成代理对象 因此，目标对象就是被修改后的代理对象 --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;!-- 如果项目中有接口时，仍希望使用CGHLIB动态代理 proxy-target-class=\"true\"：告诉框架使用cglib动态代理 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt;&lt;/beans&gt; 测试类MyTest.java 123456789public class MyTest { public void Test(){ String config = \"applicationContext.xml\"; ApplicationContext ac = new ClassPathXmlApplicationContext(config); //根据对象名获取代理对象 SomeService proxy = (SomeService) ac.getBean(\"someService\"); //proxy.\"目标方法名\"(); }}","link":"/2021/04/23/aop/"},{"title":"Dubbo","text":"Dubbo一、简介1、dubbo是一个轻量级Java RPC框架，用于分布式系统的开发 RPC 全称Remote Procedure Call，远程过程调用。是一种进程间的通信方式，是一种技术思想，而不是规范。 它允许程序调用另一个地址空间（网络的另一台机器上）的过程或函 数，而不用开发人员显式编码这个调用的细节。 调用本地方法和调用远程方法一样。 分布式系统 分布式系统是若干独立计算机（服务器）的集合，这些计算机对于用户来说就像单个相 关系统， 分布式系统（distributed system）是建立在网络之上的服务器端一种结构。 分布式系统中的计算机可以使用不同的操作系统，可以运行不同应用程序提供服务，将 服务分散部署到多个计算机服务器上。 2、基本架构 服务提供者 服务消费者 注册中心 监控中心 二、使用方式1、直接连接直接连接只需要服务提供者和服务消费者，不使用注册中心， 但需要将服务提供者打包成jar文件，在消费者中通过groupId引用。 服务提供者 User（需要进行序列化） 1234567891011121314151617181920212223242526272829303132333435363738public class User implements Serializable { private String id; private String name; private String age; private String address; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; }} UserService接口 1234public interface UserService { User queryUser(String id);} UserServiceImpl 1234567891011public class UserServiceImpl implements UserService { @Override public User queryUser(String id) { User user = new User(); user.setId(id); user.setName(\"lisi\"); user.setAge(\"20\"); user.setAddress(\"中国\"); return user; }} dubbo配置文件 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!--声明服务提供者的名称，保证唯一性--&gt; &lt;dubbo:application name=\"001-link-userService-provider\" /&gt; &lt;!--设置访问服务协议的名称与端口号--&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!--暴露服务接口，registry：如果不使用注册中心，则使用N/A，即直连方式--&gt; &lt;dubbo:service interface=\"cn.krain.dubbo.service.UserService\" ref=\"userService\" registry=\"N/A\"/&gt; &lt;!--将接口的实现类加入到spring容器中--&gt; &lt;bean id=\"userService\" class=\"cn.krain.dubbo.service.impl.UserServiceImpl\"/&gt;&lt;/beans&gt; web.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dubbo-userService-provider.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 服务消费者 UserController 12345678910111213@Controllerpublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/user\") public String getUser(Model model, String id){ User user = userService.queryUser(id); model.addAttribute(user); return \"index\"; }} dubbo配置文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!--声明服务消费者名称，保证唯一性--&gt; &lt;dubbo:application name=\"002-link-consumer\"/&gt; &lt;!--引用远程服务接口--&gt; &lt;dubbo:reference id=\"userService\" interface=\"cn.krain.dubbo.service.UserService\" url=\"dubbo://localhost:20880\" registry=\"N/A\"/&gt;&lt;/beans&gt; spring配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=\"cn.krain.dubbo.web\"/&gt; &lt;!--配置注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:002-link-consumer.xml,classpath:application.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp 123456789101112131415&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;用户详情&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户详情&lt;/h1&gt;&lt;div&gt; id:${user.id}&lt;br&gt; name:${user.name}&lt;br&gt; age:${user.age}&lt;br&gt; address:${user.address}&lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、使用注册中心使用zookeeper注册中心 该方法与直接连接相比只有dubbo配置文件有所不同，以及需要一个接口工程，其他均相同。该接口工程中只有序列化的实体类和所创建的接口，在服务者和消费者使用时通过groupId引用即可。 服务提供者的dubbo配置文件： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!--生名服务提供者名称，保证唯一性--&gt; &lt;dubbo:application name=\"007-zk-userservice-provider\"/&gt; &lt;!--设置协议和端口--&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!--使用zookeeper注册中心--&gt; &lt;dubbo:registry address=\"zookeeper://localhost:2181\"/&gt; &lt;!--暴露接口--&gt; &lt;dubbo:service interface=\"cn.krain.dubbo.service.UserService\" ref=\"userServiceImpl\"/&gt; &lt;!--将实现类放入到spring容器中--&gt; &lt;bean id=\"userServiceImpl\" class=\"cn.krain.dubbo.service.impl.UserServiceImpl\"/&gt;&lt;/beans&gt; 服务消费者 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!--声明服务消费者名称--&gt; &lt;dubbo:application name=\"008-zk-consumer\"/&gt; &lt;!--指定zookeeper注册中心--&gt; &lt;dubbo:registry address=\"zookeeper://localhost:2181\"/&gt; &lt;!--引用远程接口服务--&gt; &lt;dubbo:reference id=\"userService\" interface=\"cn.krain.dubbo.service.UserService\"/&gt;&lt;/beans&gt; 三、版本控制一个接口可以有不同的实现方式，通过版本号调用不同的实现类。四、监控中心","link":"/2021/04/24/Dubbo/"}],"tags":[],"categories":[]}